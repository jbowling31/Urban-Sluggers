<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport"
  content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,viewport-fit=cover,user-scalable=no" />
<title>Urban Slugger Prototype</title>
<style>
  html, body { margin:0; height:100%; background:#0b1020; overflow:hidden; }
  #wrap { position:relative; width:100%; height:100%; touch-action:none; }
  canvas { display:block; width:100%; height:100%; }

  .hud{
    position:absolute; inset:0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
    color:#fff;
    pointer-events:none;
  }

  .topbar{
    position:absolute; left:10px; top:10px;
    background: rgba(0,0,0,.45);
    padding:8px 10px;
    border-radius:12px;
    font-weight:800;
    line-height:1.15;
    max-width: calc(100% - 20px);
    white-space: pre-line;
    z-index: 5;
  }

  .hint{
    position:absolute; right:10px; top:10px;
    background: rgba(0,0,0,.35);
    padding:8px 10px;
    border-radius:12px;
    font-size:12px;
    text-align:right;
    white-space: pre-line;
    z-index: 5;
  }

  .restartBtn{
    position:absolute;
    right: 10px;
    top: 92px;
    width: 108px;
    height: 44px;
    border-radius: 14px;

    display:flex;
    align-items:center;
    justify-content:center;

    background: rgba(255,255,255,.10);
    border: 1px solid rgba(255,255,255,.18);
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);

    font-weight: 950;
    pointer-events:auto;
    user-select:none;
    -webkit-user-select:none;
    touch-action:none;
    z-index: 6;
  }
  .restartBtn:active { transform: translateY(1px); }

  .controls{
    position:absolute;
    left:0; right:0; bottom:0;
    display:flex;
    justify-content:space-between;
    align-items:flex-end;
    gap:12px;
    pointer-events:auto;

    padding: 12px;
    padding-left:  calc(12px + env(safe-area-inset-left));
    padding-right: calc(12px + env(safe-area-inset-right));
    padding-bottom:calc(12px + env(safe-area-inset-bottom));

    z-index: 10; /* below modal */
  }

  .leftCol{
    display:grid;
    grid-template-columns: 1fr;
    gap:10px;
    align-items:end;
    pointer-events:auto;
  }

  .stanceRow{
    display:grid;
    grid-template-columns: 62px 62px 62px;
    gap:10px;
    justify-content:start;
    pointer-events:auto;
  }

  .btnCol{
    display:grid;
    grid-template-columns: 62px 62px;
    grid-template-rows: 62px 62px;
    gap:10px;
    justify-content:end;
    pointer-events:auto;
  }

  .wide{ grid-column: 1 / span 2; }

  .btn{
    width:62px; height:62px;
    border-radius:16px;
    background: rgba(255,255,255,.10);
    border: 1px solid rgba(255,255,255,.18);
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    color:#fff; font-weight:900;
    display:flex; align-items:center; justify-content:center;
    user-select:none; -webkit-user-select:none;
    touch-action:none;
    font-size: 12px;
  }
  .btn:active { transform: translateY(1px); }

  /* Joystick (smaller) */
  .joy{
    width: 140px;
    height: 140px;
    border-radius: 999px;
    background: rgba(255,255,255,.08);
    border: 1px solid rgba(255,255,255,.18);
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    position: relative;
    pointer-events:auto;
    touch-action:none;
  }
  .joy::after{
    content:"";
    position:absolute;
    inset: 15px;
    border-radius: 999px;
    border: 1px dashed rgba(255,255,255,.18);
    opacity:.65;
  }
  .joyKnob{
    width: 58px;
    height: 58px;
    border-radius: 999px;
    background: rgba(255,255,255,.18);
    border: 1px solid rgba(255,255,255,.22);
    position:absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    pointer-events:none;
  }
  .joyLabel{
    position:absolute;
    left:50%;
    top:50%;
    transform: translate(-50%, 44px);
    font-size: 10px;
    font-weight: 950;
    opacity: .75;
    pointer-events:none;
    white-space:nowrap;
  }

  /* Upgrade modal ON TOP of everything */
  .modal{
    position:absolute; inset:0;
    display:flex; align-items:center; justify-content:center;
    background: rgba(0,0,0,.60);
    pointer-events:auto;
    padding: 18px;
    padding-bottom: calc(18px + env(safe-area-inset-bottom));
    z-index: 1000;
  }
  .modal[hidden]{ display:none; }

  .panel{
    width:min(560px, 94vw);
    background: rgba(15,18,35,.92);
    border: 1px solid rgba(255,255,255,.18);
    border-radius: 18px;
    padding: 16px;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    box-shadow: 0 18px 50px rgba(0,0,0,.45);
  }
  .title{ font-weight: 950; font-size: 20px; margin-bottom: 6px; }
  .sub{ opacity:.9; font-weight:800; margin-bottom: 12px; }
  .sub2{ opacity:.7; font-size: 12px; margin-top: 10px; font-weight:800; }
  .choices{
    display:grid;
    grid-template-columns: 1fr;
    gap: 10px;
  }
  @media (min-width: 560px){
    .choices{ grid-template-columns: 1fr 1fr 1fr; }
  }
  .upg{
    border-radius: 16px;
    padding: 12px;
    background: rgba(255,255,255,.10);
    border: 1px solid rgba(255,255,255,.18);
    color:#fff;
    cursor:pointer;
    user-select:none;
    pointer-events:auto;
  }
  .upg:active{ transform: translateY(1px); }
  .upg .n{ font-weight: 950; margin-bottom: 4px; }
  .upg .d{ opacity:.88; font-weight: 800; font-size: 12px; line-height:1.25; }
  .upg .k{ opacity:.65; font-size: 12px; margin-top: 6px; font-weight:950; }

  /* Force landscape layout */
  @media screen and (orientation: portrait) {
    body::before {
      content: "Rotate your device ↻";
      position: fixed;
      inset: 0;
      background: #0b1020;
      color: #fff;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    canvas, .hud { display: none; }
  }
</style>
<link rel="icon" href="data:,">
</head>

<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="topbar" id="topbar">Loading…</div>
    <div class="hint" id="hint">
PC: Mouse aim • Click swing
Keys: Arrows aim • J swing
K VERT • L HORZ • T toggle
R restart
    </div>

    <div class="restartBtn" id="btnRestart">RESTART</div>

    <div class="modal" id="upgradeModal" hidden>
      <div class="panel">
        <div class="title" id="upgradeTitle">Level Complete!</div>
        <div class="sub" id="upgradeSub">Pick your upgrade.</div>
        <div class="choices" id="upgradeChoices"></div>
        <div class="sub2" id="upgradeTip">Tip: press 1 / 2 / 3 on keyboard (or tap a card).</div>
      </div>
    </div>

    <div class="controls">
      <div class="leftCol">
        <div class="joy" id="joy">
          <div class="joyKnob" id="joyKnob"></div>
          <div class="joyLabel">AIM</div>
        </div>
        <div class="stanceRow">
          <div class="btn" id="btnToggle">TOGGLE</div>
          <div class="btn" id="btnRighty">RIGHTY</div>
          <div class="btn" id="btnLefty">LEFTY</div>
        </div>
      </div>

      <div class="btnCol">
        <div class="btn" id="btnVert">VERT</div>
        <div class="btn" id="btnHorz">HORZ</div>
        <div class="btn wide" id="btnSwing">SWING</div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // Prevent mobile zoom (pinch + double-tap)
  document.addEventListener("touchmove", (e) => {
    if (e.touches && e.touches.length > 1) e.preventDefault();
  }, { passive: false });

  document.addEventListener("touchstart", (e) => {
    if (e.touches && e.touches.length > 1) e.preventDefault();
  }, { passive: false });

  ["gesturestart", "gesturechange", "gestureend"].forEach((evt) => {
    document.addEventListener(evt, (e) => e.preventDefault(), { passive: false });
  });

  let lastTouchEnd = 0;
  document.addEventListener("touchend", (e) => {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) e.preventDefault();
    lastTouchEnd = now;
  }, { passive: false });

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    canvas.width  = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resize);
  window.addEventListener("orientationchange", resize);

  // Assets
  const IMG = {};
  function loadImg(key, src){
    return new Promise((res) => {
      const im = new Image();
      im.onload = () => { IMG[key] = im; res({key, ok:true, src}); };
      im.onerror = () => { console.warn("❌ Asset failed:", src); res({key, ok:false, src}); };
      im.src = src;
    });
  }

  const ASSETS = [
    loadImg("bg", "assets/back_alley_background.png"),
    loadImg("bg2", "assets/emoji_town_background.png"),
    loadImg("player", "assets/baeball_player.png"),
    loadImg("pSwingFollow", "assets/baseball_player_swing.png"),
    loadImg("ball", "assets/evil_baseball_1.png"),
    loadImg("enemy2", "assets/creepy_smile.png"),
    loadImg("explosion", "assets/explosion.png"),
    loadImg("skillV", "assets/vertical_slash_skill.png"),
    loadImg("skillH", "assets/horizontal_slash_skill.png"),
  ];

  // Config
  const STRIKE_ZONE_VISIBLE = true;
  const PLATE_Y_FRAC = 0.90;

  const STRIKE_W = 150;
  const BAND_H = 24;

  const SHOULDER_FRAC = 0.35;
  const KNEE_FRAC     = 0.74;

  const STANCE_OFFSET = 130;

  const AIM_PAD = 10;
  const CHASE_MARGIN = 22;

  const BAT_R_BASE = 22;
  const BAT_R_PER_UPG = 0.55;

  const PERFECT_W = 0.055;
  const GOOD_W    = 0.14;
  const LATE_GRACE = 0.06;

  // overlap relative to BAT area
  const OVERLAP_PERFECT = 0.92;
  const OVERLAP_GOOD    = 0.75;

  const POPUP_LIFE = 0.62;
  const POPUP_RISE = -130;
  const POPUP_STACK_STEP = 42;

  const PLATE_HOLD_EPS = 0.1;

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function clamp01(v){ return Math.max(0, Math.min(1, v)); }
  function lerp(a, b, t){ return a + (b - a) * t; }

  function norm2(x, y){
    const l = Math.hypot(x, y) || 1;
    return { x: x / l, y: y / l };
  }

  function circleRectHit(cx, cy, r, rx, ry, rw, rh){
    const nx = clamp(cx, rx, rx+rw);
    const ny = clamp(cy, ry, ry+rh);
    const dx = cx - nx, dy = cy - ny;
    return (dx*dx + dy*dy) <= r*r;
  }

  function circleOverlapArea(r1, r2, d){
    if (d >= r1 + r2) return 0;
    if (d <= Math.abs(r1 - r2)){
      const rMin = Math.min(r1, r2);
      return Math.PI * rMin * rMin;
    }
    const a1 = 2 * Math.acos((r1*r1 + d*d - r2*r2) / (2*r1*d));
    const a2 = 2 * Math.acos((r2*r2 + d*d - r1*r1) / (2*r2*d));
    const area1 = 0.5 * r1*r1 * (a1 - Math.sin(a1));
    const area2 = 0.5 * r2*r2 * (a2 - Math.sin(a2));
    return area1 + area2;
  }

  function getPlate(W, H){
    return { x: W * 0.5, y: H * PLATE_Y_FRAC };
  }

  function getContactBandFromPlate(W, H){
    const plate = getPlate(W, H);
    const bot = Math.min(H - 18, plate.y);
    const y = bot - BAND_H;
    return { x: plate.x - STRIKE_W / 2, y, w: STRIKE_W, h: BAND_H, top: y, bot };
  }

  function getStrikeZoneFromPlayer(W, H, playerY, playerH){
    const plate = getPlate(W, H);
    const shoulderY = playerY + playerH * SHOULDER_FRAC;
    const kneeY     = playerY + playerH * KNEE_FRAC;
    const h = Math.max(36, kneeY - shoulderY);
    return { x: plate.x - STRIKE_W / 2, y: shoulderY, w: STRIKE_W, h, bot: kneeY };
  }

  function stackOffset(i){
    if (i === 0) return 0;
    const side = (i % 2 === 1) ? 1 : -1;
    const step = Math.ceil(i / 2);
    return side * step * POPUP_STACK_STEP;
  }

  // Player
  const player = {
    x: 0, y: 0,
    w: 120, h: 180,
    stance: "righty",
    facing: 1,

    swing: false,
    swingTimer: 0,
    swingWindow: 0.18,
    swingAge: 999,
    swingPoseTimer: 0,
    swingPoseDur: 0.16,
    swingCD: 0,
    swingCDDur: 0.10,

    swingConsumed: false,

    skillVCD: 0,
    skillHCD: 0,
    skillVCDDur: 6.0,
    skillHCDDur: 7.5,
  };

  function setStance(which){
    player.stance = which;
    player.facing = (which === "righty") ? 1 : -1;
  }
  function toggleStance(){
    setStance(player.stance === "righty" ? "lefty" : "righty");
  }

  // Input
  const input = { swing:false, skillV:false, skillH:false };

  function bindTap(el, fn){
    el.addEventListener("pointerdown", (e)=>{ e.preventDefault(); fn(); });
  }

  // Swing must be press-per-swing: trigger on pointerup to avoid “hold”
  function bindPressOnce(el, fn){
    el.addEventListener("pointerdown", (e)=>{ e.preventDefault(); });
    el.addEventListener("pointerup", (e)=>{ e.preventDefault(); fn(); });
    el.addEventListener("pointercancel", (e)=>{ e.preventDefault(); });
  }

  bindPressOnce(document.getElementById("btnSwing"), ()=> input.swing = true);
  bindTap(document.getElementById("btnVert"),  ()=> input.skillV = true);
  bindTap(document.getElementById("btnHorz"),  ()=> input.skillH = true);

  bindTap(document.getElementById("btnToggle"), toggleStance);
  bindTap(document.getElementById("btnRighty"), ()=> setStance("righty"));
  bindTap(document.getElementById("btnLefty"),  ()=> setStance("lefty"));

  const restartBtn = document.getElementById("btnRestart");
  bindTap(restartBtn, () => resetRun());

  // Aim spot
  const aim = { nx: 0, ny: 0 };
  let lastZone = { x:0, y:0, w:100, h:100 };

  function clampAimToExpandedZone(zone, px, py){
    const ex = zone.x - CHASE_MARGIN;
    const ey = zone.y - CHASE_MARGIN;
    const ew = zone.w + CHASE_MARGIN*2;
    const eh = zone.h + CHASE_MARGIN*2;

    const x = clamp(px, ex + AIM_PAD, ex + ew - AIM_PAD);
    const y = clamp(py, ey + AIM_PAD, ey + eh - AIM_PAD);

    const nx = ((x - (ex + AIM_PAD)) / Math.max(1, (ew - AIM_PAD*2))) * 2 - 1;
    const ny = ((y - (ey + AIM_PAD)) / Math.max(1, (eh - AIM_PAD*2))) * 2 - 1;
    aim.nx = clamp(nx, -1, 1);
    aim.ny = clamp(ny, -1, 1);
  }

  function getAimPoint(zone){
    const ex = zone.x - CHASE_MARGIN;
    const ey = zone.y - CHASE_MARGIN;
    const ew = zone.w + CHASE_MARGIN*2;
    const eh = zone.h + CHASE_MARGIN*2;

    const x = ex + AIM_PAD + ((aim.nx + 1) * 0.5) * (ew - AIM_PAD*2);
    const y = ey + AIM_PAD + ((aim.ny + 1) * 0.5) * (eh - AIM_PAD*2);

    return {
      x: clamp(x, ex + AIM_PAD, ex + ew - AIM_PAD),
      y: clamp(y, ey + AIM_PAD, ey + eh - AIM_PAD),
    };
  }

  // Joystick
  const joyEl = document.getElementById("joy");
  const knobEl = document.getElementById("joyKnob");
  let joyActive = false;
  let joyPid = -1;

  function setKnob(dx, dy){
    knobEl.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
  }

  function updateAimFromJoyPointer(clientX, clientY){
    const r = joyEl.getBoundingClientRect();
    const cx = r.left + r.width/2;
    const cy = r.top + r.height/2;

    const maxR = (Math.min(r.width, r.height) * 0.5) - 18;
    let dx = clientX - cx;
    let dy = clientY - cy;

    const d = Math.hypot(dx, dy) || 1;
    if (d > maxR){
      dx = dx / d * maxR;
      dy = dy / d * maxR;
    }

    aim.nx = clamp(dx / maxR, -1, 1);
    aim.ny = clamp(dy / maxR, -1, 1);

    setKnob(dx, dy);
  }

  joyEl.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    joyActive = true;
    joyPid = e.pointerId;
    joyEl.setPointerCapture(joyPid);
    updateAimFromJoyPointer(e.clientX, e.clientY);
  });

  joyEl.addEventListener("pointermove", (e) => {
    if (!joyActive || e.pointerId !== joyPid) return;
    e.preventDefault();
    updateAimFromJoyPointer(e.clientX, e.clientY);
  });

  function endJoy(e){
    if (!joyActive || e.pointerId !== joyPid) return;
    e.preventDefault();
    joyActive = false;
    joyPid = -1;
  }
  joyEl.addEventListener("pointerup", endJoy);
  joyEl.addEventListener("pointercancel", endJoy);
  joyEl.addEventListener("lostpointercapture", () => { joyActive = false; joyPid = -1; });

  // PC mouse aim + click swing
  canvas.addEventListener("contextmenu", (e) => e.preventDefault());

  canvas.addEventListener("pointermove", (e) => {
    if (e.pointerType !== "mouse") return;
    if (upgradeOpen) return;

    const rect = canvas.getBoundingClientRect();
    clampAimToExpandedZone(lastZone, e.clientX - rect.left, e.clientY - rect.top);
  });

  canvas.addEventListener("pointerdown", (e) => {
    if (e.pointerType !== "mouse") return;
    if (upgradeOpen) return;
    if (e.button === 0) input.swing = true;
  });

  // Game state
  const topbar = document.getElementById("topbar");

  let score = 0;
  let hp = 3;

  let combo = 0;
  let comboTimer = 0;
  const COMBO_DECAY = 2.25;

  function getMult(){
    return Math.min(6, 1 + Math.floor(combo / 10));
  }

  let hitStop = 0;
  let shakeT = 0;
  let shakeMag = 0;

  let fxVertT = 0;
  let fxHorzT = 0;

  const buffs = { slowmo:0, double:0, magnet:0, shield:0 };

  const upgrades = {
    hitboxBonus: 0,
    cdMul: 1.0,
    perfectBonus: 0.00,
    skillDamageBonus: 0,

    autoPitchCount: 0,
    autoPitchInterval: 5.0,
    autoPitchT: 0,
  };

  const shots = [];
  const balls = [];
  const bossPitches = [];
  const returns = [];
  const explosions = [];
  const pickups = [];
  const popups = [];

  let spawnT = 0;
  let swingToken = 0;
  let popupStackI = 0;

  // Boss
  const boss = {
    alive: false,
    x: 0, y: 0,
    r: 86,
    hp: 0,
    maxHp: 0,
    shootT: 0,
    shootInterval: 0.95,
  };

  // Levels
  let level = 1;
  let levelKills = 0;
  let levelTime = 0;
  let levelBannerT = 1.4;

  const LEVELS = [
    { type:"kills", target:8 },
    { type:"survive", target:18 },
    { type:"kills", target:14 },
    { type:"survive", target:24 },
    { type:"boss", target:1 },
  ];

  function getLevelSpec(lv){
    const base = LEVELS[(lv-1) % LEVELS.length];
    const tier = Math.floor((lv-1) / LEVELS.length);
    const scale = 1 + tier * 0.20;

    const spec = { ...base };
    if (spec.type === "kills") spec.target = Math.round(spec.target * scale);
    if (spec.type === "survive") spec.target = Math.round(spec.target * scale);
    if (spec.type === "boss") spec.target = 1;

    if (spec.type === "kills") spec.banner = `LEVEL ${lv} — Protect the Plate: ${spec.target} KOs`;
    if (spec.type === "survive") spec.banner = `LEVEL ${lv} — Hold the Line: ${spec.target}s`;
    if (spec.type === "boss") spec.banner = `LEVEL ${lv} — BOSS: HIT IT BACK`;
    return spec;
  }

  function getTheme(lv){
    return (lv >= 6) ? "emoji" : "alley";
  }

  function difficultyT(){
    return clamp01((level - 1) / 18);
  }

  // Upgrade modal (unchanged logic)
  const upgradeModal = document.getElementById("upgradeModal");
  const upgradeChoicesEl = document.getElementById("upgradeChoices");
  const upgradeTitle = document.getElementById("upgradeTitle");
  const upgradeSub = document.getElementById("upgradeSub");
  const upgradeTip = document.getElementById("upgradeTip");

  let upgradeOpen = false;
  let pendingNextLevel = null;

  const UPGRADE_CATALOG = {
    hitbox_plus: { name:"Bigger Sweet Spot", desc:"+20px bat contact radius (easier hits).", apply(){ upgrades.hitboxBonus += 20; } },
    autopitch_2: { name:"Auto Pitch", desc:"Every 5s throw 2 friendly balls.", apply(){ upgrades.autoPitchCount = Math.max(upgrades.autoPitchCount, 2); } },
    cooldown:    { name:"Quick Hands", desc:"Skill cooldowns -10%.", apply(){ upgrades.cdMul *= 0.90; } },
    hp:          { name:"Extra Heart", desc:"+1 HP (cap 6).", apply(){ hp = Math.min(6, hp + 1); } },
    shield:      { name:"Shield Charge", desc:"+1 shield (cap 3).", apply(){ buffs.shield = Math.min(3, buffs.shield + 1); } },
    perfect:     { name:"Timing Master", desc:"Perfect window +0.02s.", apply(){ upgrades.perfectBonus += 0.02; } },
    skill_dmg:   { name:"Sharper Skills", desc:"VERT/HORZ damage +1.", apply(){ upgrades.skillDamageBonus += 1; } },
    autopitch_3: { name:"Auto Pitch+", desc:"Auto Pitch now fires 3 balls.", apply(){ upgrades.autoPitchCount = Math.max(upgrades.autoPitchCount, 3); } },
    autopitch_faster:{ name:"Rapid Pitch", desc:"Auto Pitch interval -1s (min 2s).", apply(){ upgrades.autoPitchInterval = Math.max(2.0, upgrades.autoPitchInterval - 1.0); } },
  };

  function getLevelUpgradeChoices(lv){
    if (lv === 1) return ["hitbox_plus"];
    if (lv === 2) return ["autopitch_2"];

    const pool = ["hitbox_plus","cooldown","hp","shield","perfect","skill_dmg","autopitch_3","autopitch_faster"];
    const weighted = pool.slice();
    if (upgrades.autoPitchCount > 0) weighted.push("autopitch_3","autopitch_faster");

    const pick = [];
    while (pick.length < 3){
      const id = weighted[(Math.random()*weighted.length)|0];
      if (!pick.includes(id)) pick.push(id);
    }
    return pick;
  }

  function openUpgradeModal(nextLv){
    upgradeOpen = true;
    pendingNextLevel = nextLv;

    const choices = getLevelUpgradeChoices(level);
    upgradeTitle.textContent = `Level ${level} Complete!`;
    upgradeSub.textContent = (choices.length === 1) ? "Upgrade unlocked. Tap to continue." : "Pick your upgrade.";
    upgradeTip.textContent = (choices.length === 1) ? "Tap the card to continue." : "Tip: press 1 / 2 / 3 on keyboard (or tap a card).";

    upgradeChoicesEl.innerHTML = choices.map((id, idx) => {
      const u = UPGRADE_CATALOG[id];
      const keyHint = (choices.length === 1) ? "" : `(${idx+1})`;
      return `
        <div class="upg" data-upg="${id}" data-idx="${idx}">
          <div class="n">${u?.name ?? id}</div>
          <div class="d">${u?.desc ?? ""}</div>
          <div class="k">${keyHint}</div>
        </div>
      `;
    }).join("");

    upgradeModal.hidden = false;
  }

  function closeUpgradeModal(){
    upgradeOpen = false;
    upgradeModal.hidden = true;
  }

  function chooseUpgradeByIndex(i){
    const el = upgradeChoicesEl.querySelector('.upg[data-idx="' + i + '"]');
    if (!el) return;
    const id = el.dataset.upg;

    UPGRADE_CATALOG[id]?.apply?.();

    buffs.double = Math.max(buffs.double, 1.2);
    shakeMag = Math.max(shakeMag, 9);
    shakeT = Math.max(shakeT, 0.22);

    closeUpgradeModal();
    startLevel(pendingNextLevel);
    pendingNextLevel = null;
  }

  upgradeChoicesEl.addEventListener("pointerup", (e) => {
    const card = e.target.closest(".upg");
    if (!card) return;
    chooseUpgradeByIndex(Number(card.dataset.idx));
  });

  // FX
  function spawnExplosion(x, y, big=false){
    explosions.push({ x, y, frame:0, t:0, fps:24, frameCount:5, size: big ? 120 : 96, alive:true });
  }

  function spawnPopupStacked(anchorX, anchorY, text, kind){
    const offX = stackOffset(popupStackI++);
    popups.push({ x: anchorX + offX, y: anchorY, vy: POPUP_RISE, t: 0, life: POPUP_LIFE, text, kind, alive: true });
  }

  function maybeDropPickup(x, y){
    const p = 0.08 + Math.min(0.06, combo / 200);
    if (Math.random() > p) return;

    const roll = Math.random();
    let type = "double";
    if (roll < 0.25) type = "slowmo";
    else if (roll < 0.50) type = "double";
    else if (roll < 0.75) type = "magnet";
    else type = "shield";

    pickups.push({ x, y, r:18, vy:-240, t:0, type, alive:true });
  }

  function applyPickup(type){
    if (type === "slowmo") buffs.slowmo = Math.max(buffs.slowmo, 3.0);
    if (type === "double") buffs.double = Math.max(buffs.double, 5.0);
    if (type === "magnet") buffs.magnet = Math.max(buffs.magnet, 5.0);
    if (type === "shield") buffs.shield = Math.min(3, buffs.shield + 1);

    shakeMag = Math.max(shakeMag, 4);
    shakeT = Math.max(shakeT, 0.12);
  }

  function endSwingImmediately(){
    player.swing = false;
    player.swingTimer = 0;
    player.swingAge = 999;
  }

  // Swing
  function startSwing(){
    if (player.swingCD > 0) return;
    swingToken++;
    popupStackI = 0;

    player.swingConsumed = false;

    player.swing = true;
    player.swingTimer = player.swingWindow;
    player.swingAge = 0;
    player.swingPoseTimer = player.swingPoseDur;
    player.swingCD = player.swingCDDur;
  }

  function applyPlateDamage(amount){
    if (buffs.shield > 0) buffs.shield--;
    else hp = Math.max(0, hp - amount);

    combo = 0;
    comboTimer = 0;

    shakeMag = Math.max(shakeMag, 10);
    shakeT = Math.max(shakeT, 0.20);
  }

  // Auto Pitch (friendly) — in boss fight: only homes to BOSS
  const SHOT_HOMING = true;
  const SHOT_HOMING_RANGE = 1200;
  const SHOT_TURN_RATE = 14;
  const SHOT_LEAD_TIME = 0.20;

  function acquireShotTarget(s){
    if (boss.alive) return boss;
    let best = null;
    let bestScore = -Infinity;
    for (const b of balls){
      if (!b.alive) continue;
      const d = Math.hypot(b.x - s.x, b.y - s.y);
      if (d > SHOT_HOMING_RANGE) continue;
      const score = -d + (b.toPlateDist ? (-b.toPlateDist * 0.04) : 0);
      if (score > bestScore){ bestScore = score; best = b; }
    }
    return best;
  }

  function fireAutoPitch(W, H){
    if (upgrades.autoPitchCount <= 0) return;

    const band = getContactBandFromPlate(W, H);
    const cx = band.x + band.w/2;
    const cy = band.y + band.h/2;

    const startX = cx + (player.facing === 1 ? -22 : 22);
    const startY = cy + 30;

    for (let i = 0; i < upgrades.autoPitchCount; i++){
      const spread = (i - (upgrades.autoPitchCount-1)/2) * 22;
      shots.push({
        x: startX,
        y: startY + spread,
        r: 14,
        speed: 920,
        vx: (player.facing === 1 ? 920 : -920),
        vy: 0,
        homing: true,
        target: null,
        alive: true,
        dmg: 1,
      });
    }
  }

  function bossDamage(dmg, isPerfect=false){
    boss.hp = Math.max(0, boss.hp - dmg);

    hitStop = isPerfect ? 0.09 : 0.06;
    shakeMag = Math.max(shakeMag, isPerfect ? 16 : 12);
    shakeT = Math.max(shakeT, 0.22);

    spawnExplosion(boss.x, boss.y + boss.r * 0.1, isPerfect);

    if (boss.hp <= 0){
      boss.alive = false;
      levelKills = 1;
      finishLevel();
    }
  }

  function updateShots(dt, W, H){
    for (const s of shots){
      if (!s.alive) continue;

      if (SHOT_HOMING && s.homing){
        if (!s.target || (s.target !== boss && !s.target.alive)) s.target = acquireShotTarget(s);

        if (s.target){
          const tx = s.target.x + (s.target.vx || 0) * SHOT_LEAD_TIME;
          const ty = s.target.y + (s.target.vy || 0) * SHOT_LEAD_TIME;

          const desired = norm2(tx - s.x, ty - s.y);
          const cur = norm2(s.vx, s.vy);

          const t = clamp01(SHOT_TURN_RATE * dt);
          const nx = cur.x + (desired.x - cur.x) * t;
          const ny = cur.y + (desired.y - cur.y) * t;
          const nd = norm2(nx, ny);

          s.vx = nd.x * (s.speed || 920);
          s.vy = nd.y * (s.speed || 920);
        }
      }

      s.x += s.vx * dt;
      s.y += s.vy * dt;

      if (s.x > W + 120 || s.x < -120 || s.y > H + 120 || s.y < -120) s.alive = false;

      // Boss collision: shots can damage boss directly in boss rounds
      if (boss.alive){
        const d = Math.hypot(s.x - boss.x, s.y - boss.y);
        if (d <= boss.r * 0.72 + s.r){
          s.alive = false;
          bossDamage(s.dmg, false);
          continue;
        }
        continue;
      }

      // Normal collision: shots hit enemies
      for (const b of balls){
        if (!b.alive) continue;
        const dx = b.x - s.x, dy = b.y - s.y;
        const rr = (b.r + s.r);
        if ((dx*dx + dy*dy) <= rr*rr){
          s.alive = false;
          b.hp -= s.dmg;
          hitStop = 0.06;
          shakeMag = Math.max(shakeMag, 10);
          shakeT = Math.max(shakeT, 0.18);
          spawnExplosion(b.x, b.y, false);
          if (b.hp <= 0) b.alive = false;
          break;
        }
      }
    }

    for (let i = shots.length - 1; i >= 0; i--){
      if (!shots[i].alive) shots.splice(i, 1);
    }
  }

function spawnEnemy(W, H, kind="normal"){
  const speedScale = 1 + (level-1) * 0.06;

  // All basic enemies are 1 HP (one hit kills)
  let r = 42, hpv = 1, scoreV = 10, spd = (280 + Math.random()*120) * speedScale;

  if (kind === "fast"){ r=30; hpv=1; scoreV=18; spd=(380 + Math.random()*140) * speedScale; }

  // keep "heavy" as a different FEEL (bigger, maybe more score), but still 1 HP
  if (kind === "heavy"){ r=52; hpv=1; scoreV=25; spd=(240 + Math.random()*100) * speedScale; }

  const lane = (Math.random() * 3) | 0;
  let x, y;
  if (lane === 0){ x = Math.random()*W; y = -80; }
  else if (lane === 1){ x = -80; y = Math.random()*(H*0.62); }
  else { x = W + 80; y = Math.random()*(H*0.62); }

  balls.push({
    kind, x, y, r,
    alive:true,
    hp: hpv,
    scoreV,
    speed: spd,
    vx:0, vy:0,
    wobPhase: Math.random()*Math.PI*2,
    wobMag: 10,
    toPlateDist: 9999,
    lastHitSwingToken: -1,
    pendingPlate: false,
    justHitT: 0,
  });
}


  function dealDamageToEnemyBall(b, dmg, {isPerfect=false, fromSkill=false} = {}){
    if (!b.alive) return false;

    b.hp -= dmg;

    hitStop = fromSkill ? 0.06 : (isPerfect ? 0.085 : 0.045);
    shakeMag = Math.max(shakeMag, fromSkill ? 12 : (isPerfect ? 14 : 9));
    shakeT = Math.max(shakeT, fromSkill ? 0.20 : (isPerfect ? 0.22 : 0.16));

    if (b.hp > 0){
      combo++;
      comboTimer = COMBO_DECAY;
      score += Math.round(6 * getMult() * (buffs.double > 0 ? 2 : 1));
      spawnExplosion(b.x, b.y, false);
      return true;
    }

    b.alive = false;

    combo++;
    comboTimer = COMBO_DECAY;

    const mult = getMult();
    const bonus = isPerfect ? 1.35 : 1.0;
    const doubleOn = (buffs.double > 0) ? 2 : 1;

    score += Math.round(b.scoreV * mult * bonus * doubleOn);
    levelKills++;

    spawnExplosion(b.x, b.y, isPerfect || fromSkill);
    maybeDropPickup(b.x, b.y);

    const spec = getLevelSpec(level);
    if (!upgradeOpen && spec.type === "kills" && levelKills >= spec.target) finishLevel();
    return true;
  }

  // Boss pitch types
  const BOSS_PITCH_TYPES = [
    { id:"FASTBALL", speedMul:1.18, curve:0.0,  sink:0.00, lateBreak:0.00 },
    { id:"CURVE",    speedMul:0.96, curve:1.0,  sink:0.14, lateBreak:0.25 },
    { id:"SLIDER",   speedMul:1.05, curve:0.7,  sink:0.06, lateBreak:0.55 },
    { id:"SINKER",   speedMul:1.02, curve:0.25, sink:0.34, lateBreak:0.62 },
    { id:"CHANGE",   speedMul:0.84, curve:0.35, sink:0.10, lateBreak:0.40 },
  ];

  function pickBossPitchType(){
    const t = difficultyT();
    const early = [0,0,0,1,4];
    const mid   = [0,1,2,3,4];
    const late  = [0,1,2,2,3,3,4];
    const pool = (t < 0.33) ? early : (t < 0.70) ? mid : late;
    return BOSS_PITCH_TYPES[pool[(Math.random()*pool.length)|0]];
  }

  function startBossFight(W, H){
    const t = difficultyT();
    boss.alive = true;
    boss.maxHp = Math.round(14 + level * 1.4);
    boss.hp = boss.maxHp;

    boss.x = W * 0.5;
    boss.y = Math.max(88, H * lerp(0.16, 0.20, t));
    boss.r = 86;

    boss.shootT = 0;
    boss.shootInterval = lerp(1.05, 0.62, t);
  }

  function spawnBossPitch(W, H, zone, band){
    const plate = getPlate(W, H);
    const t = difficultyT();

    const pt = pickBossPitchType();
    const r = 32 + Math.random() * 7;

    const baseSpeed = lerp(360, 560, t);
    const spd = baseSpeed * pt.speedMul + Math.random() * 35;

    const ballChance = lerp(0.18, 0.30, t);
    const isBallPitch = Math.random() < ballChance;

    const targetY = band.y + band.h/2;

    const strikeX = zone.x + 14 + Math.random() * (zone.w - 28);
    const ballX = plate.x + (Math.random() < 0.5 ? -1 : 1) * (zone.w * 0.65 + 50 + Math.random() * 120);
    const targetX = isBallPitch ? ballX : strikeX;

    const dir = norm2(targetX - boss.x, targetY - boss.y);
    const breakSign = (Math.random() < 0.5) ? -1 : 1;

    bossPitches.push({
      x: boss.x,
      y: boss.y + boss.r * 0.25,
      r,
      alive: true,
      hp: 1,
      speed: spd,
      vx: dir.x * spd,
      vy: dir.y * spd,

      pitchId: pt.id,
      curveK: pt.curve * breakSign,
      sinkK: pt.sink,
      lateBreak: pt.lateBreak,

      phase: Math.random() * Math.PI * 2,
      isBallPitch,
      toPlateDist: 9999,
      lastHitSwingToken: -1,
      pendingPlate: false,
      labelT: 0.75,
    });
  }

  function applyBossPitchMovement(p, dt){
    const prog = clamp01(1 - (p.toPlateDist / 520));
    const late = clamp01((prog - p.lateBreak) / Math.max(0.0001, (1 - p.lateBreak)));

    p.phase += dt * 7.0;
    const wob = Math.sin(p.phase);

    const vdir = norm2(p.vx, p.vy);
    const perp = { x: -vdir.y, y: vdir.x };

    const curveMag = (18 + 32 * late) * p.curveK * (0.65 + 0.35 * wob);
    p.vx += perp.x * curveMag * dt;
    p.vy += perp.y * curveMag * dt;

    const sinkMag = (65 * late) * p.sinkK;
    p.vy += sinkMag * dt;

    const nd = norm2(p.vx, p.vy);
    p.vx = nd.x * p.speed;
    p.vy = nd.y * p.speed;
  }

  function createReturnBall(fromX, fromY, grade, aimPt, zone, timing01){
    const timing = clamp((0.5 - timing01) * 2, -1, 1); // early:+1, late:-1

    const zoneCx = zone.x + zone.w/2;
    const zoneCy = zone.y + zone.h/2;

    const ax = (aimPt.x - zoneCx) / Math.max(1, zone.w/2);
    const ay = (aimPt.y - zoneCy) / Math.max(1, zone.h/2);

    const pullX = player.facing * timing * 180;
    const aimX = clamp(ax, -1, 1) * 150;
    const aimY = clamp(ay, -1, 1) * 70;

    const targetX = boss.x + pullX + aimX;
    const targetY = boss.y + aimY;

    const dir = norm2(targetX - fromX, targetY - fromY);

    const isPerfect = grade === "perfect";
    const dmg = isPerfect ? 2 : 1;

    const speed =
      isPerfect ? 980 :
      (grade === "good" ? 920 : 860);

    returns.push({
      x: fromX,
      y: fromY,
      r: 14,
      vx: dir.x * speed,
      vy: dir.y * speed,
      alive: true,
      dmg,
      isPerfect,
    });
  }

  function updateBossFight(dt, W, H, zone, band, swingActive, expandedZone){
    if (!boss.alive) return;

    const tx = band.x + band.w/2;
    const ty = band.y + band.h/2;

    boss.shootT += dt;
    if (boss.shootT >= boss.shootInterval){
      boss.shootT = 0;
      spawnBossPitch(W, H, zone, band);

      const t = difficultyT();
      if (t > 0.55 && Math.random() < 0.22){
        spawnBossPitch(W, H, zone, band);
      }
    }

    for (const p of bossPitches){
      if (!p.alive) continue;

      p.labelT = Math.max(0, p.labelT - dt);

      applyBossPitchMovement(p, dt);

      p.x += p.vx * dt;
      p.y += p.vy * dt;

      p.toPlateDist = Math.hypot(tx - p.x, ty - p.y);

      if (p.pendingPlate) continue;

      if (p.y + p.r >= band.bot){
        const hittableNow = swingActive && !player.swingConsumed &&
          circleRectHit(p.x, p.y, p.r, expandedZone.x, expandedZone.y, expandedZone.w, expandedZone.h);

        if (hittableNow){
          p.pendingPlate = true;
          p.y = band.bot - p.r - PLATE_HOLD_EPS;
          continue;
        }

        p.alive = false;
        const hitsPlateLane = circleRectHit(p.x, p.y, p.r, band.x, band.y, band.w, band.h);
        if (hitsPlateLane) applyPlateDamage(1);
      }
    }

    for (const r of returns){
      if (!r.alive) continue;

      r.x += r.vx * dt;
      r.y += r.vy * dt;

      if (r.x < -200 || r.x > W + 200 || r.y < -200 || r.y > H + 200){
        r.alive = false;
        continue;
      }

      const d = Math.hypot(r.x - boss.x, r.y - boss.y);
      if (d <= (boss.r * 0.72 + r.r)){
        r.alive = false;
        bossDamage(r.dmg, r.isPerfect);
      }
    }

    for (let i = bossPitches.length - 1; i >= 0; i--) if (!bossPitches[i].alive) bossPitches.splice(i, 1);
    for (let i = returns.length - 1; i >= 0; i--) if (!returns[i].alive) returns.splice(i, 1);
  }

  // Skills
  function useSkillV(zone){
    if (player.skillVCD > 0) return;
    player.skillVCD = player.skillVCDDur * upgrades.cdMul;
    fxVertT = 0.22;

    const stripeW = 140;
    const stripeX = (zone.x + zone.w/2) - stripeW/2;
    const dmg = 2 + upgrades.skillDamageBonus;

    const pool = boss.alive ? bossPitches : balls;
    for (const b of pool){
      if (!b.alive) continue;
      if (b.x >= stripeX && b.x <= stripeX + stripeW){
        if (boss.alive){
          b.alive = false;
          spawnExplosion(b.x, b.y, true);
        } else {
          dealDamageToEnemyBall(b, dmg, { fromSkill:true });
        }
      }
    }
  }

  function useSkillH(zone){
    if (player.skillHCD > 0) return;
    player.skillHCD = player.skillHCDDur * upgrades.cdMul;
    fxHorzT = 0.22;

    const bandH = 110;
    const centerY = (zone.y + zone.h/2);
    const bandY = centerY - bandH/2;
    const dmg = 2 + upgrades.skillDamageBonus;

    const pool = boss.alive ? bossPitches : balls;
    for (const b of pool){
      if (!b.alive) continue;
      if (b.y >= bandY && b.y <= bandY + bandH){
        if (boss.alive){
          b.alive = false;
          spawnExplosion(b.x, b.y, true);
        } else {
          dealDamageToEnemyBall(b, dmg, { fromSkill:true });
        }
      }
    }
  }

  // Run control
  function resetRun(){
    score = 0;
    hp = 3;

    combo = 0;
    comboTimer = 0;

    upgrades.hitboxBonus = 0;
    upgrades.cdMul = 1.0;
    upgrades.perfectBonus = 0.00;
    upgrades.skillDamageBonus = 0;
    upgrades.autoPitchCount = 0;
    upgrades.autoPitchInterval = 5.0;
    upgrades.autoPitchT = 0;

    level = 1;
    levelKills = 0;
    levelTime = 0;
    levelBannerT = 1.4;

    buffs.slowmo = 0;
    buffs.double = 0;
    buffs.magnet = 0;
    buffs.shield = 0;

    setStance("righty");

    player.swing = false;
    player.swingTimer = 0;
    player.swingAge = 999;
    player.swingPoseTimer = 0;
    player.swingCD = 0;
    player.swingConsumed = false;

    player.skillVCD = 0;
    player.skillHCD = 0;
    fxVertT = 0;
    fxHorzT = 0;

    balls.length = 0;
    bossPitches.length = 0;
    returns.length = 0;
    explosions.length = 0;
    pickups.length = 0;
    shots.length = 0;
    popups.length = 0;

    spawnT = 0;

    hitStop = 0;
    shakeT = 0;
    shakeMag = 0;

    boss.alive = false;
    boss.hp = 0;
    boss.maxHp = 0;

    upgradeOpen = false;
    pendingNextLevel = null;
    upgradeModal.hidden = true;

    swingToken = 0;
    popupStackI = 0;

    aim.nx = 0;
    aim.ny = 0;
    setKnob(0, 0);
  }

  function startLevel(lv){
    level = lv;
    levelKills = 0;
    levelTime = 0;
    levelBannerT = 1.4;
    spawnT = 0;

    balls.length = 0;
    bossPitches.length = 0;
    returns.length = 0;
    explosions.length = 0;
    pickups.length = 0;
    popups.length = 0;

    boss.alive = false;
    boss.hp = 0;
    boss.maxHp = 0;
  }

  function finishLevel(){
    openUpgradeModal(level + 1);
  }

// ===== Keyboard (no-hold / no-repeat) =====
const heldKeys = new Set();

function keyName(e){
  return (e.key || "").toLowerCase();
}

window.addEventListener("keydown", (e) => {
  const k = keyName(e);

  // prevent OS/browser key-repeat from spamming swing
  if (e.repeat) return;
  if (heldKeys.has(k)) return;
  heldKeys.add(k);

  // always allow restart
  if (k === "r"){ resetRun(); return; }

  // modal choices
  if (upgradeOpen){
    if (k === "1") chooseUpgradeByIndex(0);
    if (k === "2") chooseUpgradeByIndex(1);
    if (k === "3") chooseUpgradeByIndex(2);
    return;
  }

  if (k === "t") toggleStance();
  if (k === "a") setStance("righty");
  if (k === "d") setStance("lefty");

  // one-shot press actions
  if (k === "j") input.swing = true;   // swing cannot be held
  if (k === "k") input.skillV = true;
  if (k === "l") input.skillH = true;

  // arrow aim (also one-shot-per-press; hold won't repeat)
  const step = 0.11;
  if (e.key === "ArrowLeft")  aim.nx = clamp(aim.nx - step, -1, 1);
  if (e.key === "ArrowRight") aim.nx = clamp(aim.nx + step, -1, 1);
  if (e.key === "ArrowUp")    aim.ny = clamp(aim.ny - step, -1, 1);
  if (e.key === "ArrowDown")  aim.ny = clamp(aim.ny + step, -1, 1);

  if (e.key.startsWith("Arrow")){
    const r = joyEl.getBoundingClientRect();
    const maxR = (Math.min(r.width, r.height) * 0.5) - 18;
    setKnob(aim.nx * maxR, aim.ny * maxR);
  }
});

window.addEventListener("keyup", (e) => {
  heldKeys.delete(keyName(e));
});

// safety: never get "stuck held" if tab loses focus
window.addEventListener("blur", () => heldKeys.clear());
document.addEventListener("visibilitychange", () => {
  if (document.hidden) heldKeys.clear();
});


  // Step
  function step(dt, W, H){
    if (upgradeOpen) return;

    if (hitStop > 0){
      hitStop -= dt;
      return;
    }

    if (buffs.slowmo > 0) buffs.slowmo = Math.max(0, buffs.slowmo - dt);
    if (buffs.double > 0) buffs.double = Math.max(0, buffs.double - dt);
    if (buffs.magnet > 0) buffs.magnet = Math.max(0, buffs.magnet - dt);

    const timeScale = (buffs.slowmo > 0) ? 0.65 : 1.0;
    const sdt = dt * timeScale;

    const spec = getLevelSpec(level);
    levelTime += sdt;

    if (combo > 0){
      comboTimer -= sdt;
      if (comboTimer <= 0) combo = 0;
    }

    if (player.swingCD > 0) player.swingCD = Math.max(0, player.swingCD - sdt);
    player.skillVCD = Math.max(0, player.skillVCD - sdt);
    player.skillHCD = Math.max(0, player.skillHCD - sdt);

    if (fxVertT > 0) fxVertT = Math.max(0, fxVertT - sdt);
    if (fxHorzT > 0) fxHorzT = Math.max(0, fxHorzT - sdt);

    // popups
    for (const p of popups){
      if (!p.alive) continue;
      p.t += sdt;
      p.y += p.vy * sdt;
      if (p.t >= p.life) p.alive = false;
    }
    for (let i = popups.length - 1; i >= 0; i--){
      if (!popups[i].alive) popups.splice(i, 1);
    }

    // anchor player/zone
    const plate = getPlate(W, H);
    const band  = getContactBandFromPlate(W, H);

    const bandCx = band.x + band.w / 2;
    const playerCenterX = bandCx + (player.stance === "righty" ? -STANCE_OFFSET : STANCE_OFFSET);
    player.x = playerCenterX - player.w/2;
    player.y = clamp(plate.y - player.h + 14, 0, H - player.h - 10);

    const zone = getStrikeZoneFromPlayer(W, H, player.y, player.h);
    lastZone = zone;
    const aimPt = getAimPoint(zone);

    // swing input + timers
    if (input.swing) startSwing();
    input.swing = false;

    if (player.swing){
      player.swingTimer = Math.max(0, player.swingTimer - sdt);
      player.swingAge += sdt;
      player.swingPoseTimer = Math.max(0, player.swingPoseTimer - sdt);
      if (player.swingTimer <= 0) player.swing = false;
    } else {
      player.swingAge = Math.min(999, player.swingAge + sdt);
      player.swingPoseTimer = Math.max(0, player.swingPoseTimer - sdt);
    }

    const swingActive = (player.swing || player.swingAge <= player.swingWindow + LATE_GRACE);

    const expandedZone = {
      x: zone.x - CHASE_MARGIN,
      y: zone.y - CHASE_MARGIN,
      w: zone.w + CHASE_MARGIN*2,
      h: zone.h + CHASE_MARGIN*2,
    };

    // skills
    if (input.skillV) useSkillV(zone);
    input.skillV = false;

    if (input.skillH) useSkillH(zone);
    input.skillH = false;

    // auto pitch
    if (upgrades.autoPitchCount > 0){
      upgrades.autoPitchT += sdt;
      if (upgrades.autoPitchT >= upgrades.autoPitchInterval){
        upgrades.autoPitchT = 0;
        fireAutoPitch(W, H);
      }
    }

    // boss start
    if (spec.type === "boss" && !boss.alive){
      startBossFight(W, H);
    }

    // spawn normal enemies
    if (spec.type !== "boss"){
      spawnT += sdt;
      const baseInterval = 1.05;
      const interval = Math.max(0.42, baseInterval - (level-1) * 0.05);

      if (spawnT >= interval){
        spawnT = 0;

        const r = Math.random();
        let kind = "normal";

        const fastChance = Math.min(0.32, 0.08 + (level-1)*0.02);
        const heavyChance = Math.min(0.26, 0.06 + (level-1)*0.015);

        if (r < fastChance) kind = "fast";
        else if (r < fastChance + heavyChance) kind = "heavy";

        spawnEnemy(W, H, kind);

        if (level >= 7 && Math.random() < 0.10){
          spawnEnemy(W, H, Math.random() < 0.5 ? "fast" : "normal");
        }
      }
    }

    // move normal enemies + plate-hold
    if (spec.type !== "boss"){
      const tx = band.x + band.w/2;
      const ty = band.y + band.h/2;

      for (const b of balls){
        if (!b.alive) continue;

        b.justHitT = Math.max(0, b.justHitT - sdt);

        if (b.pendingPlate) continue;

        b.wobPhase += sdt * 6;

        const dx = tx - b.x;
        const dy = ty - b.y;
        const dist = Math.hypot(dx, dy) || 1;
        b.toPlateDist = dist;

        const dir = { x: dx/dist, y: dy/dist };
        const perp = { x: -dir.y, y: dir.x };
        const wob = Math.sin(b.wobPhase) * b.wobMag;

        b.vx = dir.x * b.speed + perp.x * wob;
        b.vy = dir.y * b.speed + perp.y * wob;

        b.x += b.vx * sdt;
        b.y += b.vy * sdt;

        const minX = zone.x + b.r;
        const maxX = zone.x + zone.w - b.r;
        b.x = clamp(b.x, minX, maxX);

        if (b.y + b.r >= band.bot){
          const hittableNow = swingActive && !player.swingConsumed &&
            circleRectHit(b.x, b.y, b.r, expandedZone.x, expandedZone.y, expandedZone.w, expandedZone.h);

          if (hittableNow){
            b.pendingPlate = true;
            b.y = band.bot - b.r - PLATE_HOLD_EPS;
          } else {
            b.alive = false;
            applyPlateDamage(1);
          }
        }
      }
    }

    // boss update
    if (spec.type === "boss"){
      updateBossFight(sdt, W, H, zone, band, swingActive, expandedZone);
    }

    // pickups
    for (const p of pickups){
      p.t += sdt;
      p.vy += 900 * sdt;
      p.y += p.vy * sdt;

      const tx = band.x + band.w/2;
      p.x += (tx - p.x) * sdt * 0.25;

      if (circleRectHit(p.x, p.y, p.r, player.x, player.y, player.w, player.h)){
        p.alive = false;
        applyPickup(p.type);
      }
      if (p.y > H + 80) p.alive = false;
    }

    // explosions
    for (const ex of explosions){
      ex.t += sdt;
      const fd = 1 / ex.fps;
      while (ex.t >= fd){
        ex.t -= fd;
        ex.frame++;
        if (ex.frame >= ex.frameCount){
          ex.alive = false;
          break;
        }
      }
    }

    // shots
    updateShots(sdt, W, H);

    // SWING contact (one hit per swing)
    if (swingActive && !player.swingConsumed){
      const batR = BAT_R_BASE + upgrades.hitboxBonus * BAT_R_PER_UPG;

      const perfectWindow = PERFECT_W + upgrades.perfectBonus;
      const goodWindow    = GOOD_W + upgrades.perfectBonus;

      const timing01 = clamp01(player.swingAge / Math.max(0.0001, player.swingWindow));
      const timeGrade =
        (player.swingAge <= perfectWindow) ? "perfect" :
        (player.swingAge <= goodWindow)    ? "good" :
        "normal";

      const thrPerfect = OVERLAP_PERFECT;
      const thrGood    = OVERLAP_GOOD;

      const pool = boss.alive ? bossPitches : balls;

      let didAnyContact = false;

      for (const b of pool){
        if (!b.alive) continue;
        if (b.lastHitSwingToken === swingToken) continue;

        const inHittable = circleRectHit(b.x, b.y, b.r, expandedZone.x, expandedZone.y, expandedZone.w, expandedZone.h);
        if (!inHittable) continue;

        const d = Math.hypot(b.x - aimPt.x, b.y - aimPt.y);
        const overlapA = circleOverlapArea(b.r, batR, d);
        const batA = Math.PI * batR * batR;
        const frac = overlapA / (batA || 1);
        if (frac <= 0.001) continue;

        const overlapGrade =
          (frac >= thrPerfect) ? "perfect" :
          (frac >= thrGood)    ? "good" :
          "normal";

        const grade =
          (overlapGrade === "perfect" || timeGrade === "perfect") ? "perfect" :
          (overlapGrade === "good"    || timeGrade === "good")    ? "good" :
          "normal";

        b.lastHitSwingToken = swingToken;
        b.pendingPlate = false;

        didAnyContact = true;

        if (boss.alive){
          b.alive = false;

          if (grade === "good") spawnPopupStacked(aimPt.x, aimPt.y - 22, "GOOD", "good");
          if (grade === "perfect") spawnPopupStacked(aimPt.x, aimPt.y - 22, "PERFECT!", "perfect");

          createReturnBall(b.x, b.y, grade, aimPt, zone, timing01);

          combo += (grade === "perfect") ? 2 : 1;
          comboTimer = COMBO_DECAY;

          shakeMag = Math.max(shakeMag, grade === "perfect" ? 14 : 10);
          shakeT = Math.max(shakeT, 0.16);
          spawnExplosion(b.x, b.y, grade !== "normal");
        } else {
          const didHit = dealDamageToEnemyBall(b, 1, { isPerfect: (grade === "perfect") });
          if (didHit && b.alive){
            b.justHitT = 0.22;
            b.y -= 26;
            b.vy = -Math.abs(b.vy) * 0.85;
            b.vx *= 0.55;
          }

          if (didHit){
            if (grade === "good"){
              spawnPopupStacked(aimPt.x, aimPt.y - 22, "GOOD", "good");
              combo += 1; comboTimer = COMBO_DECAY; score += 2 * getMult();
            } else if (grade === "perfect"){
              spawnPopupStacked(aimPt.x, aimPt.y - 22, "PERFECT!", "perfect");
              combo += 3; comboTimer = COMBO_DECAY; score += 6 * getMult();
            }
          }
        }

        // Consume swing immediately (prevents “holding swing hits everything”)
        if (didAnyContact){
          player.swingConsumed = true;
          endSwingImmediately();
          break;
        }
      }
    }

    // Resolve pending plate-cross AFTER swing
    if (!boss.alive){
      for (const b of balls){
        if (!b.alive) continue;
        if (!b.pendingPlate) continue;

        if (b.justHitT > 0){
          b.pendingPlate = false;
          continue;
        }

        b.pendingPlate = false;
        b.alive = false;
        applyPlateDamage(1);
      }
    } else {
      const bandRect = band;
      for (const p of bossPitches){
        if (!p.alive) continue;
        if (!p.pendingPlate) continue;

        p.pendingPlate = false;
        p.alive = false;

        const hitsPlateLane = circleRectHit(p.x, p.y, p.r, bandRect.x, bandRect.y, bandRect.w, bandRect.h);
        if (hitsPlateLane) applyPlateDamage(1);
      }
    }

    if (spec.type === "survive" && levelTime >= spec.target) finishLevel();

    // cleanup
    for (let i = balls.length - 1; i >= 0; i--) if (!balls[i].alive) balls.splice(i, 1);
    for (let i = explosions.length - 1; i >= 0; i--) if (!explosions[i].alive) explosions.splice(i, 1);
    for (let i = pickups.length - 1; i >= 0; i--) if (!pickups[i].alive) pickups.splice(i, 1);

    if (levelBannerT > 0) levelBannerT = Math.max(0, levelBannerT - sdt);

    if (shakeT > 0){
      shakeT = Math.max(0, shakeT - dt);
      shakeMag = Math.max(0, shakeMag - dt * 60);
    }

    // UI
    const mult = getMult();
    const shieldTxt = buffs.shield > 0 ? `🛡${buffs.shield} ` : "";
    const slowTxt = buffs.slowmo > 0 ? "🕒 " : "";
    const dblTxt = buffs.double > 0 ? "x2 " : "";
    const magTxt = buffs.magnet > 0 ? "🧲 " : "";
    const apTxt = upgrades.autoPitchCount > 0 ? `🎯${upgrades.autoPitchCount}/${upgrades.autoPitchInterval.toFixed(0)}s ` : "";

    let objTxt = "";
    if (spec.type === "kills") objTxt = `OBJ ${levelKills}/${spec.target}`;
    if (spec.type === "survive") objTxt = `OBJ ${Math.floor(levelTime)}/${spec.target}s`;
    if (spec.type === "boss") objTxt = boss.alive ? `BOSS ${boss.hp}/${boss.maxHp}` : "BOSS";

    const cdV = player.skillVCD > 0 ? player.skillVCD.toFixed(1) : "READY";
    const cdH = player.skillHCD > 0 ? player.skillHCD.toFixed(1) : "READY";

    topbar.textContent =
      `Lv ${level} (${getTheme(level)}) • ${objTxt} • ${player.stance.toUpperCase()}\n` +
      `Score ${score} • HP ${hp} • Combo ${combo} • x${mult} • ${shieldTxt}${slowTxt}${dblTxt}${magTxt}${apTxt}\n` +
      `VERT ${cdV} • HORZ ${cdH}`;
  }

  // Draw
  function draw(W, H){
    let camX = 0, camY = 0;
    if (shakeT > 0){
      camX = (Math.random()*2 - 1) * shakeMag;
      camY = (Math.random()*2 - 1) * shakeMag;
    }

    ctx.save();
    ctx.translate(camX, camY);

    const theme = getTheme(level);
    const bg = (theme === "emoji" && IMG.bg2) ? IMG.bg2 : IMG.bg;

    if (bg){
      const ar = bg.width / bg.height;
      const tr = W / H;
      let dw, dh, dx, dy;
      if (ar > tr){ dh = H; dw = H * ar; dx = (W - dw)/2; dy = 0; }
      else { dw = W; dh = W / ar; dx = 0; dy = (H - dh)/2; }
      ctx.drawImage(bg, dx, dy, dw, dh);
    } else {
      ctx.fillStyle = "#101a3a";
      ctx.fillRect(0,0,W,H);
    }

    const plate = getPlate(W, H);
    const band  = getContactBandFromPlate(W, H);
    const zone  = getStrikeZoneFromPlayer(W, H, player.y, player.h);
    lastZone = zone;

    const aimPt = getAimPoint(zone);
    const batR = BAT_R_BASE + upgrades.hitboxBonus * BAT_R_PER_UPG;

    // BIG boss HP bar (top)
    if (boss.alive){
      const bw = Math.min(620, W - 40);
      const bh = 18;
      const bx = (W - bw) / 2;
      const by = 14;

      ctx.save();
      ctx.globalAlpha = 0.70;
      ctx.fillStyle = "#000";
      ctx.fillRect(bx, by, bw, bh);

      ctx.globalAlpha = 1;
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(255,255,255,0.70)";
      ctx.strokeRect(bx, by, bw, bh);

      const frac = clamp(boss.hp / Math.max(1, boss.maxHp), 0, 1);
      ctx.fillStyle = "#fff";
      ctx.fillRect(bx + 2, by + 2, (bw - 4) * frac, bh - 4);

      ctx.font = "950 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "#0b1020";
      ctx.fillText(`BOSS HP ${boss.hp}/${boss.maxHp}`, bx + bw/2, by + bh/2);
      ctx.restore();
    }

    // Strike zone
    if (STRIKE_ZONE_VISIBLE){
      ctx.save();
      ctx.globalAlpha = 0.14;
      ctx.fillStyle = "#00ffff";
      ctx.fillRect(zone.x, zone.y, zone.w, zone.h);
      ctx.globalAlpha = 0.92;
      ctx.lineWidth = 4;
      ctx.strokeStyle = "rgba(0,255,255,0.95)";
      ctx.strokeRect(zone.x, zone.y, zone.w, zone.h);

      ctx.globalAlpha = 0.28;
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(255,255,255,0.55)";
      ctx.strokeRect(zone.x - CHASE_MARGIN, zone.y - CHASE_MARGIN, zone.w + CHASE_MARGIN*2, zone.h + CHASE_MARGIN*2);
      ctx.restore();
    }

    // Bat circle
    ctx.save();
    ctx.globalAlpha = 0.20;
    ctx.fillStyle = "rgba(0,0,0,0.60)";
    ctx.beginPath();
    ctx.arc(aimPt.x + 2, aimPt.y + 2, batR, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.08;
    ctx.fillStyle = "rgba(255,255,255,0.90)";
    ctx.beginPath();
    ctx.arc(aimPt.x, aimPt.y, batR, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.90;
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(255,255,255,0.92)";
    ctx.beginPath();
    ctx.arc(aimPt.x, aimPt.y, batR, 0, Math.PI*2);
    ctx.stroke();

    ctx.globalAlpha = 0.70;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(aimPt.x - 14, aimPt.y);
    ctx.lineTo(aimPt.x + 14, aimPt.y);
    ctx.moveTo(aimPt.x, aimPt.y - 14);
    ctx.lineTo(aimPt.x, aimPt.y + 14);
    ctx.stroke();
    ctx.restore();

    // bottom wash
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "#000";
    ctx.fillRect(0, band.y, W, H - band.y);
    ctx.globalAlpha = 1;

    // plate marker
    ctx.save();
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.ellipse(plate.x, plate.y + 18, 46, 16, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // Boss
    if (boss.alive){
      const enemyImg = (theme === "emoji" && IMG.enemy2) ? IMG.enemy2 : IMG.ball;

      ctx.save();
      ctx.globalAlpha = 0.55;
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.ellipse(boss.x, boss.y + boss.r * 0.75, boss.r * 0.98, boss.r * 0.42, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.65)";
      ctx.shadowBlur = 14;
      ctx.shadowOffsetY = 6;
      if (enemyImg) ctx.drawImage(enemyImg, boss.x - boss.r, boss.y - boss.r, boss.r*2, boss.r*2);
      else {
        ctx.beginPath(); ctx.arc(boss.x, boss.y, boss.r, 0, Math.PI*2);
        ctx.fillStyle = "#ffcc33";
        ctx.fill();
      }
      ctx.restore();
    }

    // Player
    const useSwingPose = player.swingPoseTimer > 0;
    const pimg = useSwingPose ? IMG.pSwingFollow : IMG.player;

    if (pimg){
      ctx.save();
      const px = player.x, py = player.y;
      if (player.facing === -1){
        ctx.translate(px + player.w/2, 0);
        ctx.scale(-1, 1);
        ctx.translate(-(px + player.w/2), 0);
      }
      ctx.drawImage(pimg, px, py, player.w, player.h);
      ctx.restore();
    } else {
      ctx.fillStyle = "#fff";
      ctx.fillRect(player.x, player.y, player.w, player.h);
    }

    // friendly shots
    const shotImg = IMG.ball;
    for (const s of shots){
      if (!s.alive) continue;
      const size = s.r * 2;
      if (shotImg) ctx.drawImage(shotImg, s.x - s.r, s.y - s.r, size, size);
      else { ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fillStyle = "#fff"; ctx.fill(); }
    }

    // returns
    for (const r of returns){
      if (!r.alive) continue;
      const size = r.r * 2;
      if (shotImg) ctx.drawImage(shotImg, r.x - r.r, r.y - r.r, size, size);
      else { ctx.beginPath(); ctx.arc(r.x, r.y, r.r, 0, Math.PI*2); ctx.fillStyle = "#fff"; ctx.fill(); }
    }

    // enemies or boss pitches
    const enemyImg = (theme === "emoji" && IMG.enemy2) ? IMG.enemy2 : IMG.ball;
    const pool = boss.alive ? bossPitches : balls;

    for (const b of pool){
      if (!b.alive) continue;

      const size = b.r * 2;

      ctx.save();
      ctx.globalAlpha = 0.55;
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.ellipse(b.x, b.y + b.r * 0.60, b.r * 0.92, b.r * 0.42, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.65)";
      ctx.shadowBlur = 10;
      ctx.shadowOffsetY = 4;

      if (enemyImg) ctx.drawImage(enemyImg, b.x - b.r, b.y - b.r, size, size);
      else { ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fillStyle = "#ff3b3b"; ctx.fill(); }
      ctx.restore();

      if (boss.alive && b.pitchId && b.labelT > 0){
        ctx.save();
        ctx.globalAlpha = clamp(b.labelT / 0.75, 0, 1) * 0.95;
        ctx.font = "950 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.textAlign = "center";
        ctx.shadowColor = "rgba(0,0,0,0.55)";
        ctx.shadowBlur = 8;
        ctx.fillStyle = "#fff";
        ctx.fillText(b.pitchId, b.x, b.y - b.r - 14);
        ctx.restore();
      }
    }

    // pickups
    for (const p of pickups){
      ctx.globalAlpha = 0.9;
      ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fillStyle = "#ffffff";
      ctx.fill();
      ctx.globalAlpha = 1;

      ctx.fillStyle = "#0b1020";
      ctx.font = "900 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      const label = p.type === "slowmo" ? "S" : p.type === "double" ? "2X" : p.type === "magnet" ? "M" : "🛡";
      ctx.fillText(label, p.x, p.y + 5);
    }

    // explosions
    const exImg = IMG.explosion;
    if (exImg){
      for (const ex of explosions){
        const fw = exImg.width / ex.frameCount;
        const fh = exImg.height;
        const sx = ex.frame * fw;
        ctx.drawImage(exImg, sx, 0, fw, fh, ex.x - ex.size/2, ex.y - ex.size/2, ex.size, ex.size);
      }
    }

    // popups
    for (const p of popups){
      const t = clamp01(p.t / p.life);
      const a = 1 - t;
      const bump = 1 + Math.sin(Math.min(1, t) * Math.PI) * 0.20;

      ctx.save();
      ctx.globalAlpha = 0.95 * a;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.shadowColor = "rgba(0,0,0,0.55)";
      ctx.shadowBlur = 10;

      const fontSize = p.kind === "perfect" ? 34 : p.kind === "good" ? 28 : 24;
      ctx.font = `950 ${Math.round(fontSize * bump)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.fillStyle = p.kind === "perfect" ? "#ffd54a" : p.kind === "good" ? "#7cf7ff" : "#ffffff";

      const safeX = clamp(p.x, 50, W - 50);
      ctx.fillText(p.text, safeX, p.y);
      ctx.restore();
    }

    // level banner
    const spec = getLevelSpec(level);
    if (levelBannerT > 0 && hp > 0){
      const a = clamp(levelBannerT / 1.4, 0, 1);
      ctx.globalAlpha = 0.75 * a;
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, W, 86);
      ctx.globalAlpha = 1 * a;
      ctx.fillStyle = "#fff";
      ctx.font = "900 28px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "left";
      ctx.fillText(spec.banner, 16, 54);
      ctx.globalAlpha = 1;
    }

    // game over
    if (hp <= 0){
      ctx.globalAlpha = 0.65;
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha = 1;
      ctx.fillStyle = "#fff";
      ctx.font = "900 42px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      ctx.fillText("GAME OVER", W/2, H/2 - 12);
      ctx.font = "700 18px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("Tap RESTART.", W/2, H/2 + 26);
    }

    ctx.restore();
  }

  // Loop
  let last = 0;
  function loop(ts){
    const W = canvas.clientWidth;
    const H = canvas.clientHeight;

    const dt = Math.min(0.033, (ts - last) / 1000 || 0);
    last = ts;

    if (hp > 0) step(dt, W, H);
    draw(W, H);

    requestAnimationFrame(loop);
  }

  // Boot
  Promise.all(ASSETS).finally(() => {
    resize();
    resetRun();
    requestAnimationFrame(loop);
  });

})();
</script>
</body>
</html>
