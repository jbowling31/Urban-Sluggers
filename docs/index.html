<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport"
  content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,viewport-fit=cover,user-scalable=no" />
<title>Urban Slugger Prototype</title>
<style>
  html, body { margin:0; height:100%; background:#0b1020; overflow:hidden; }
  #wrap { position:relative; width:100%; height:100%; touch-action:none; overflow:hidden; background:#0b1020; }
  /* Fullscreen iPad-style framing (cover + crop) */
  #stage{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    transform:none;
    transform-origin: 50% 50%;
  }
  #stage canvas{ width:100%; height:100%; }

  canvas { display:block; width:100%; height:100%; }

  .hud{
    position:absolute; inset:0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
    color:#fff;
    pointer-events:none;
  }

  .topbar{
    position:absolute; left:10px; top:10px;
    background: rgba(0,0,0,.45);
    padding:8px 10px;
    border-radius:12px;
    font-weight:800;
    line-height:1.15;
    max-width: calc(100% - 20px);
    white-space: pre-line;
    z-index: 5;
  }

  .hint{
    position:absolute; right:10px; top:10px;
    background: rgba(0,0,0,.35);
    padding:8px 10px;
    border-radius:12px;
    font-size:12px;
    text-align:right;
    white-space: pre-line;
    z-index: 5;
  }

  .restartBtn{
    position:absolute;
    right: 10px;
    top: 92px;
    width: 108px;
    height: 44px;
    border-radius: 14px;

    display:flex;
    align-items:center;
    justify-content:center;

    background: rgba(255,255,255,.10);
    border: 1px solid rgba(255,255,255,.18);
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);

    font-weight: 950;
    pointer-events:auto;
    user-select:none;
    -webkit-user-select:none;
    touch-action:none;
    z-index: 6;
  }
  .restartBtn:active { transform: translateY(1px); }

  .controls{
    position:absolute;
    left:0; right:0; bottom:0;
    display:flex;
    justify-content:space-between;
    align-items:flex-end;
    gap:12px;
    pointer-events:auto;

    padding: 12px;
    padding-left:  calc(12px + env(safe-area-inset-left));
    padding-right: calc(12px + env(safe-area-inset-right));
    padding-bottom:calc(12px + env(safe-area-inset-bottom));

    z-index: 10; /* below modal */
  }

  .leftCol{
    display:grid;
    grid-template-columns: 1fr;
    gap:10px;
    align-items:end;
    pointer-events:auto;
  }

  .stanceRow{
    display:grid;
    grid-template-columns: 62px 62px 62px;
    gap:10px;
    justify-content:start;
    pointer-events:auto;
  }

  .btnCol{
    display:grid;
    grid-template-columns: 62px 62px;
    grid-template-rows: 62px 62px;
    gap:10px;
    justify-content:end;
    pointer-events:auto;
  }

  .wide{ grid-column: 1 / span 2; }

  .btn{
    width:62px; height:62px;
    border-radius:16px;
    background: rgba(255,255,255,.10);
    border: 1px solid rgba(255,255,255,.18);
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    color:#fff; font-weight:900;
    display:flex; align-items:center; justify-content:center;
    user-select:none; -webkit-user-select:none;
    touch-action:none;
    font-size: 12px;
  }
  .btn:active { transform: translateY(1px); }

  /* Joystick (smaller) */
  .joy{
    width: 140px;
    height: 140px;
    border-radius: 999px;
    background: rgba(255,255,255,.08);
    border: 1px solid rgba(255,255,255,.18);
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    position: relative;
    pointer-events:auto;
    touch-action:none;
  }
  .joy::after{
    content:"";
    position:absolute;
    inset: 15px;
    border-radius: 999px;
    border: 1px dashed rgba(255,255,255,.18);
    opacity:.65;
  }
  .joyKnob{
    width: 58px;
    height: 58px;
    border-radius: 999px;
    background: rgba(255,255,255,.18);
    border: 1px solid rgba(255,255,255,.22);
    position:absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    pointer-events:none;
  }
  .joyLabel{
    position:absolute;
    left:50%;
    top:50%;
    transform: translate(-50%, 44px);
    font-size: 10px;
    font-weight: 950;
    opacity: .75;
    pointer-events:none;
    white-space:nowrap;
  }

  
  /* Main menu */
  .menuModal{
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 24px;
    background: rgba(0,0,0,0.55);
    z-index: 30;
  }
  .menuCard{
    width: min(520px, 92vw);
    border-radius: 18px;
    padding: 18px 18px 16px;
    background: rgba(15,18,32,0.92);
    border: 2px solid rgba(255,255,255,0.16);
    box-shadow: 0 14px 40px rgba(0,0,0,0.55);
    text-align: center;
  }
  .menuTitle{
    font: 900 34px system-ui, -apple-system, Segoe UI, Roboto, Arial;
    letter-spacing: 0.5px;
    color: #fff;
    margin-bottom: 6px;
  }
  .menuSub{
    font: 650 14px system-ui, -apple-system, Segoe UI, Roboto, Arial;
    color: rgba(255,255,255,0.78);
    margin-bottom: 16px;
  }
  .menuBtns{
    display: grid;
    gap: 12px;
  }
  .menuBtns .btn{
    padding: 16px 14px;
    border-radius: 14px;
    font: 900 18px system-ui, -apple-system, Segoe UI, Roboto, Arial;
  }
  .menuHint{
    margin-top: 14px;
    font: 650 12px system-ui, -apple-system, Segoe UI, Roboto, Arial;
    color: rgba(255,255,255,0.66);
  }

/* Upgrade modal ON TOP of everything */
  .modal{
    position:absolute; inset:0;
    display:flex; align-items:center; justify-content:center;
    background: rgba(0,0,0,.60);
    pointer-events:auto;
    padding: 18px;
    padding-bottom: calc(18px + env(safe-area-inset-bottom));
    z-index: 1000;
  }
  .modal[hidden]{ display:none; }

  .panel{
    width:min(560px, 94vw);
    background: rgba(15,18,35,.92);
    border: 1px solid rgba(255,255,255,.18);
    border-radius: 18px;
    padding: 16px;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    box-shadow: 0 18px 50px rgba(0,0,0,.45);
  }
  .title{ font-weight: 950; font-size: 20px; margin-bottom: 6px; }
  .sub{ opacity:.9; font-weight:800; margin-bottom: 12px; }
  .sub2{ opacity:.7; font-size: 12px; margin-top: 10px; font-weight:800; }
  .choices{
    display:grid;
    grid-template-columns: 1fr;
    gap: 10px;
  }
  @media (min-width: 560px){
    .choices{ grid-template-columns: 1fr 1fr 1fr; }
  }
  .upg{
    border-radius: 16px;
    padding: 12px;
    background: rgba(255,255,255,.10);
    border: 1px solid rgba(255,255,255,.18);
    color:#fff;
    cursor:pointer;
    user-select:none;
    pointer-events:auto;
  }
  .upg:active{ transform: translateY(1px); }
  .upg .n{ font-weight: 950; margin-bottom: 4px; }
  .upg .d{ opacity:.88; font-weight: 800; font-size: 12px; line-height:1.25; }
  .upg .k{ opacity:.65; font-size: 12px; margin-top: 6px; font-weight:950; }

  /* Force landscape layout */
  @media screen and (orientation: portrait) {
    body::before {
      content: "Rotate your device ↻";
      position: fixed;
      inset: 0;
      background: #0b1020;
      color: #fff;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    canvas, .hud { display: none; }
  }
  [hidden] { display: none !important; }
.menuModal, .menuModal * { pointer-events:auto; touch-action:manipulation; }
.menuCard, .menuCard * { pointer-events:auto; }
#btnMenu{
  position: fixed;
  top: 14px;
  right: 14px;
  z-index: 9999;
  pointer-events: auto;
  touch-action: manipulation;
}

</style>
<link rel="icon" href="data:,">
</head>

<body><div id="wrap"><div id="stage">
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="topbar" id="topbar">Loading…</div>
    <div class="hint" id="hint">
PC: Mouse aim • Click swing
Keys: Arrows aim • J swing
K VERT • L HORZ • T toggle
R restart
    </div>

    <div class="restartBtn" id="btnRestart">RESTART</div>
    <div class="btn" id="btnMenu">MENU</div>

    <div class="menuModal" id="menuModal">
      <div class="menuCard">
        <div class="menuTitle">Urban Sluggers</div>
        <div class="menuSub">Choose a mode</div>
        <div class="menuBtns">
          <div class="btn wide" id="btnDerby">HOME RUN DERBY</div>
          <div class="btn wide" id="btnStory">STORY</div>
        </div>
        <div class="menuHint">Tap/click a mode • Esc to return to Menu</div>
      </div>
    </div>


    <div class="modal" id="upgradeModal" hidden>
      <div class="panel">
        <div class="title" id="upgradeTitle">Level Complete!</div>
        <div class="sub" id="upgradeSub">Pick your upgrade.</div>
        <div class="choices" id="upgradeChoices"></div>
        <div class="sub2" id="upgradeTip">Tip: press 1 / 2 / 3 on keyboard (or tap a card).</div>
      </div>
    </div>

    <div class="controls">
      <div class="leftCol">
        <div class="joy" id="joy">
          <div class="joyKnob" id="joyKnob"></div>
          <div class="joyLabel">AIM</div>
        </div>
        <div class="stanceRow">
          <div class="btn" id="btnToggle">TOGGLE</div>
          <div class="btn" id="btnRighty">RIGHTY</div>
          <div class="btn" id="btnLefty">LEFTY</div>
        </div>
      </div>

      <div class="btnCol">
        <div class="btn" id="btnVert">VERT</div>
        <div class="btn" id="btnHorz">HORZ</div>
        <div class="btn wide" id="btnSwing">SWING</div>
      </div>
    </div>
  </div>
</div>
</div>

<script>
(() => {
  // Prevent mobile zoom (pinch + double-tap)
  document.addEventListener("touchmove", (e) => {
    if (e.touches && e.touches.length > 1) e.preventDefault();
  }, { passive: false });

  document.addEventListener("touchstart", (e) => {
    if (e.touches && e.touches.length > 1) e.preventDefault();
  }, { passive: false });

  ["gesturestart", "gesturechange", "gestureend"].forEach((evt) => {
    document.addEventListener(evt, (e) => e.preventDefault(), { passive: false });
  });

  let lastTouchEnd = 0;
  document.addEventListener("touchend", (e) => {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) e.preventDefault();
    lastTouchEnd = now;
  }, { passive: false });

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const wrap = document.getElementById("wrap");
    const r = wrap.getBoundingClientRect();

    // True fullscreen canvas. World framing is handled by the camera (cover + crop).
    canvas.style.width  = r.width + "px";
    canvas.style.height = r.height + "px";
    canvas.width  = Math.floor(r.width * dpr);
    canvas.height = Math.floor(r.height * dpr);

    CAM.dpr = dpr;
    updateCamera(canvas);
  }
  window.addEventListener("resize", resize);
  window.addEventListener("orientationchange", resize);
// ===== Camera (fixed world, fullscreen cover) =====
const DESIGN_W = 1366;
const DESIGN_H = 1024;

// bias: 0..1.  X=0.5 centers; Y=1.0 keeps bottom visible (plate/batter safe)
const CAM_BIAS_X = 0.5;
const CAM_BIAS_Y = 1.0;

const CAM = { scale: 1, offX: 0, offY: 0, screenW: 0, screenH: 0, dpr: 1 };

// Global derby hit zone (used by physics step in both Story/Derby)
var derbyHitZone = { x:0, y:0, w:0, h:0 };

function updateCamera(canvas){
  const dpr = CAM.dpr || (window.devicePixelRatio || 1);
  const screenW = canvas.width / dpr;   // CSS px
  const screenH = canvas.height / dpr;

  const scale = Math.max(screenW / DESIGN_W, screenH / DESIGN_H); // COVER
  const offX = (screenW - DESIGN_W * scale) * CAM_BIAS_X;
  const offY = (screenH - DESIGN_H * scale) * CAM_BIAS_Y;

  CAM.scale = scale;
  CAM.offX = offX;
  CAM.offY = offY;
  CAM.screenW = screenW;
  CAM.screenH = screenH;
}

function applyCamera(ctx){
  // IMPORTANT: include DPR so transforms work in device pixels
  const dpr = CAM.dpr || 1;
  ctx.setTransform(CAM.scale * dpr, 0, 0, CAM.scale * dpr, CAM.offX * dpr, CAM.offY * dpr);
}

function screenToWorld(clientX, clientY, canvas){
  const rect = canvas.getBoundingClientRect();
  const dpr = CAM.dpr || (window.devicePixelRatio || 1);

  // client -> canvas px
  const px = (clientX - rect.left) * (canvas.width / rect.width);
  const py = (clientY - rect.top)  * (canvas.height / rect.height);

  // canvas px -> CSS px -> world
  const cx = px / dpr;
  const cy = py / dpr;

  return {
    x: (cx - CAM.offX) / CAM.scale,
    y: (cy - CAM.offY) / CAM.scale
  };
}

  // Assets
  const IMG = {};
  function loadImg(key, src){
    return new Promise((res) => {
      const im = new Image();
      im.onload = () => { IMG[key] = im; res({key, ok:true, src}); };
      im.onerror = () => { console.warn("❌ Asset failed:", src); res({key, ok:false, src}); };
      im.src = src;
    });
  }

  const ASSETS = [
    loadImg("bg", "assets/back_alley_background.png"),
    loadImg("bg2", "assets/emoji_town_background.png"),
    loadImg("bg3", "assets/subway_background.png"),
    loadImg("player", "assets/baeball_player.png"),
    loadImg("pSwingFollow", "assets/baseball_player_swing.png"),
    loadImg("ball", "assets/evil_baseball_1.png"),
    loadImg("enemy2", "assets/creepy_smile.png"),
    loadImg("enemy3", "assets/subway_sandwich.png"),
    loadImg("explosion", "assets/explosion.png"),
    loadImg("skillV", "assets/vertical_slash_skill.png"),
    loadImg("skillH", "assets/horizontal_slash_skill.png"),

    loadImg("derbyBg", "assets/homerun_derby_background.png"),
    loadImg("pitcherWindup", "assets/pitcher_banana_windup.png"),
    loadImg("pitcherPitch", "assets/pitcher_banana_pitch.png"),
  ];

  // Config
const STRIKE_ZONE_VISIBLE = true;
const PLATE_Y_FRAC = 0.90;

  // Derby camera / scaling (visual only; Story remains unchanged)
  const DERBY_VIEW_SCALE = 1.00;   // match Story pixel-for-pixel   // zoom-in factor for Derby world
  const DERBY_ZONE_SCALE = 1.00;   // 1.00 = match Story pixel-for-pixel (bigger = bigger strike zone)
  const DERBY_BATTER_X_OFFSET = 0; // + = move batter right, - = left
  const DERBY_BATTER_Y_OFFSET = 0; // + = move batter down, - = up

  // Derby pitcher tuning (also affects pitch travel time since pitches start at release point)
  const DERBY_PITCHER_SIZE_SCALE = 0.90; // smaller = farther feel + slightly more reaction clarity
  const DERBY_PITCHER_BACK_MULT  = 1.35; // higher = farther back (moves pitcher up)
  const DERBY_PITCHER_X_OFFSET   = 0;    // pixels
  const DERBY_PITCHER_Y_OFFSET   = 0;    // pixels

  function scaleRectAroundCenter(r, s){
    const cx = r.x + r.w/2;
    const cy = r.y + r.h/2;
    return { x: cx - (r.w*s)/2, y: cy - (r.h*s)/2, w: r.w*s, h: r.h*s };
  }

  function derbyScreenToWorld(sx, sy, W, H){
    // convert screen-space mouse coords to world coords under derby zoom
    return {
      x: (sx - W/2) / DERBY_VIEW_SCALE + W/2,
      y: (sy - H/2) / DERBY_VIEW_SCALE + H/2,
    };
  }

  function easeOutCubic(t){
    t = clamp01(t);
    return 1 - Math.pow(1 - t, 3);
  }

const PLATE_LANE_W = 132;   // contact band width (was STRIKE_W_BAND)
const BAND_H = 24;

const STRIKE_ZONE_W = 132;  // strike box width  ✅ change this
const STRIKE_ZONE_H = 200;  // strike box height ✅ change this
const STRIKE_ZONE_GAP = 18; // vertical gap above the band

const STANCE_OFFSET = 185;

const HP_START = 6;
const HP_MAX   = 10;


  const AIM_PAD = 10;
  const CHASE_MARGIN = 90; // wider lanes so enemies go inside/outside of zone

  const BAT_R_BASE = 22;
  const BAT_R_PER_UPG = 0.55;

  const PERFECT_W = 0.12;
  const GOOD_W    = 0.14;
  const LATE_GRACE = 0.06;

  // Derby timing/overlap windows are referenced by Story grading too.
  // Keep these globals defined so Story never crashes even if Derby hasn't been entered yet.
  const DERBY_PERFECT_W = 0.11;
  const DERBY_GOOD_W    = 0.20;
  const DERBY_MIN_CONTACT_FRAC = 0.28;
  const DERBY_OVERLAP_PERFECT  = 0.42;
  const DERBY_OVERLAP_GOOD     = 0.42;


  // overlap relative to BAT area
  const OVERLAP_PERFECT = 0.86;
  const OVERLAP_GOOD    = 0.75;

  const POPUP_LIFE = 0.62;
  const POPUP_RISE = -130;
  const POPUP_STACK_STEP = 42;

  const PLATE_HOLD_EPS = 0.1;

  // Aim penalty: if you camp aim too long, your bat radius & overlap forgiveness shrink
  const AIM_STILL_T_START = 0.85;
  const AIM_STILL_T_FULL  = 2.05;
  const AIM_STILL_EPS     = 0.012;
  const AIM_PENALTY_BAT_SHRINK = 0.35;

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function clamp01(v){ return Math.max(0, Math.min(1, v)); }
  function lerp(a, b, t){ return a + (b - a) * t; }

  function triWave(a){
    return (2 / Math.PI) * Math.asin(Math.sin(a)); // [-1..1]
  }

  function pickApproachX(zone, expandedZone){
    const padIn = 10;
    const padOut = 6;

    const leftIn  = zone.x + padIn;
    const rightIn = zone.x + zone.w - padIn;

    const leftOut  = expandedZone.x + padOut;
    const rightOut = expandedZone.x + expandedZone.w - padOut;

    const leftMid  = zone.x + zone.w * 0.28;
    const rightMid = zone.x + zone.w * 0.72;

    const pts = [
      { x: leftOut,  w: 5.0 },
      { x: rightOut, w: 5.0 },
      { x: leftIn,   w: 3.0 },
      { x: rightIn,  w: 3.0 },
      { x: leftMid,  w: 1.4 },
      { x: rightMid, w: 1.4 },
    ];

    let total = 0;
    for (const p of pts) total += p.w;

    let r = Math.random() * total;
    for (const p of pts){
      r -= p.w;
      if (r <= 0) return p.x;
    }
    return pts[0].x;
  }

  function norm2(x, y){
    const l = Math.hypot(x, y) || 1;
    return { x: x / l, y: y / l };
  }

  function circleRectHit(cx, cy, r, rx, ry, rw, rh){
    const nx = clamp(cx, rx, rx+rw);
    const ny = clamp(cy, ry, ry+rh);
    const dx = cx - nx, dy = cy - ny;
    return (dx*dx + dy*dy) <= r*r;
  }

  function circleOverlapArea(r1, r2, d){
    if (d >= r1 + r2) return 0;
    if (d <= Math.abs(r1 - r2)){
      const rMin = Math.min(r1, r2);
      return Math.PI * rMin * rMin;
    }
    const a1 = 2 * Math.acos((r1*r1 + d*d - r2*r2) / (2*r1*d));
    const a2 = 2 * Math.acos((r2*r2 + d*d - r1*r1) / (2*r2*d));
    const area1 = 0.5 * r1*r1 * (a1 - Math.sin(a1));
    const area2 = 0.5 * r2*r2 * (a2 - Math.sin(a2));
    return area1 + area2;
  }

  function getPlate(W, H){
    return { x: W * 0.5, y: H * PLATE_Y_FRAC };
  }

function getContactBandFromPlate(W, H){
  const plate = getPlate(W, H);
  const bot = Math.min(H - 18, plate.y);
  const y = bot - BAND_H;
  return { x: plate.x - PLATE_LANE_W / 2, y, w: PLATE_LANE_W, h: BAND_H, top: y, bot };
}

function getStrikeZoneFromPlate(W, H){
  const plate = getPlate(W, H);
  const band  = getContactBandFromPlate(W, H);

  const y = band.y - STRIKE_ZONE_H - STRIKE_ZONE_GAP;
  return { x: plate.x - STRIKE_ZONE_W / 2, y, w: STRIKE_ZONE_W, h: STRIKE_ZONE_H, bot: y + STRIKE_ZONE_H };
}

  // Legacy (kept for reference)
  function getStrikeZoneFromPlayer(W, H, playerX, playerY, playerW, playerH){
  const plate = getPlate(W, H);

  const w = Math.max(86, playerW * STRIKE_W_PLAYER_MUL);
  const h = Math.max(110, w * STRIKE_H_TO_W);

  const cx = plate.x;
  const cy = playerY + playerH * STRIKE_CENTER_FRAC + STRIKE_Y_OFFSET;

  const x = cx - w / 2;
  const y = clamp(cy - h / 2, 10, H - h - 120);

  return { x, y, w, h, bot: y + h };
}

  function stackOffset(i){
    if (i === 0) return 0;
    const side = (i % 2 === 1) ? 1 : -1;
    const step = Math.ceil(i / 2);
    return side * step * POPUP_STACK_STEP;
  }

  // Player
  const player = {
    x: 0, y: 0,
    w: 190, h: 285,
    stance: "righty",
    facing: 1,

    swing: false,
    swingTimer: 0,
    swingWindow: 0.18,
    swingAge: 999,
    swingPoseTimer: 0,
    swingPoseDur: 0.16,
    swingCD: 0,
    swingCDDur: 0.10,

    swingConsumed: false,

    skillVCD: 0,
    skillHCD: 0,
    skillVCDDur: 6.0,
    skillHCDDur: 7.5,
  };

  function setStance(which){
    player.stance = which;
    player.facing = (which === "righty") ? 1 : -1;
  }
  function toggleStance(){
    setStance(player.stance === "righty" ? "lefty" : "righty");
  }

  // Input
  const input = { swing:false, skillV:false, skillH:false };

  // Round countdown (shows 3..2..1..GO! and blocks gameplay briefly).
  const countdown = { active:false, t:0 };
  function startCountdown(){
    countdown.active = true;
    countdown.t = 0;
  }
  function stepCountdown(dt){
    if (!countdown.active) return false;
    countdown.t += dt;
    if (countdown.t >= 3.65) countdown.active = false;
    return countdown.active;
  }
  function countdownLabel(){
    if (!countdown.active) return "";
    if (countdown.t < 1) return "3";
    if (countdown.t < 2) return "2";
    if (countdown.t < 3) return "1";
    return "GO!";
  }
  function drawCountdownOverlay(ctx, W, H){
    if (!countdown.active) return;
    const label = countdownLabel();
    // subtle dark veil
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,W,H);
    ctx.globalAlpha = 1;
    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = (label === "GO!") ? "900 96px system-ui, -apple-system, Segoe UI, Roboto, Arial"
                                 : "900 120px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(label, W/2, H/2);
    ctx.restore();
  }

  function bindTap(el, fn){
    el.addEventListener("pointerdown", (e)=>{ e.preventDefault(); fn(); });
  }

  // Menu buttons: work reliably for both mouse + touch (without double-firing).
  function bindMenuSelect(el, fn){
    let lastFire = 0;
    const fire = (e) => {
      const now = performance.now();
      if (now - lastFire < 250) return;
      lastFire = now;
      if (e && e.preventDefault) e.preventDefault();
      fn();
    };
    el.addEventListener("pointerup", fire);
    el.addEventListener("click", fire);
  }

  function bindPressOnce(el, fn){
    el.addEventListener("pointerdown", (e)=>{ e.preventDefault(); });
    el.addEventListener("pointerup", (e)=>{ e.preventDefault(); fn(); });
    el.addEventListener("pointercancel", (e)=>{ e.preventDefault(); });
  }

  bindPressOnce(document.getElementById("btnSwing"), ()=> input.swing = true);
  bindTap(document.getElementById("btnVert"),  ()=> input.skillV = true);
  bindTap(document.getElementById("btnHorz"),  ()=> input.skillH = true);

  bindTap(document.getElementById("btnToggle"), toggleStance);
  bindTap(document.getElementById("btnRighty"), ()=> setStance("righty"));
  bindTap(document.getElementById("btnLefty"),  ()=> setStance("lefty"));

  const restartBtn = document.getElementById("btnRestart");
  bindTap(restartBtn, () => handleRestartPress());

  // Mode (menu / story / derby)
  const menuModal = document.getElementById("menuModal");
  const btnStory = document.getElementById("btnStory");
  const btnDerby = document.getElementById("btnDerby");
  const controlsEl = document.querySelector(".controls");
  const hintEl = document.getElementById("hint");
const btnMenu = document.getElementById("btnMenu");
if (btnMenu){
  btnMenu.addEventListener("pointerup", (e)=>{
    e.preventDefault();
    e.stopPropagation();
    showMenu();
  }, { passive:false });
}

  let gameMode = "menu"; // default

  function setMode(mode){
    gameMode = mode;
    updateModeUI();
  }

  function updateModeUI(){
    const inMenu = gameMode === "menu";
    menuModal.hidden = !inMenu;
    if (controlsEl) controlsEl.style.display = inMenu ? "none" : "flex";
    if (hintEl) hintEl.style.display = inMenu ? "none" : "";
    if (topbar) topbar.style.display = inMenu ? "none" : "";
    restartBtn.style.display = inMenu ? "none" : "block";
  }

  function showMenu(){
    setMode("menu");
  }

  function startStory(){
    resetRun();
    setMode("story");
    startCountdown();
  }

  // Home Run Derby state
  const derbyPitches = [];
  const derbyHits = [];

  const derby = {
    active: false,
    over: false,

    // Count-based "at bat"
    strikes: 0,
    balls: 0,

    // Strikes are HP in Derby (3-and-out)
    hp: 3,

    // Score = Home Runs only
    homeruns: 0,

    pitches: 0,
    maxPitches: Infinity,

    // Pitcher pose
    pose: "windup",
    poseT: 0,
    windupDur: 0.55,
    releaseDur: 0.12,
    followDur: 0.25,

    // Perfect-hit feel
    hitStop: 0,
    slowmoT: 0,
  };

  function resetDerby(){
    derby.active = true;
    derby.over = false;
    derby.strikes = 0;
    derby.balls = 0;
    derby.hp = 3;
    derby.homeruns = 0;
    derby.pitches = 0;
    derby.pose = "windup";
    derby.poseT = 0;


    derby.hitStop = 0;
    derby.slowmoT = 0;
    derbyPitches.length = 0;
    derbyHits.length = 0;

    popups.length = 0;
    explosions.length = 0;

    input.swing = false;
    input.skillV = false;
    input.skillH = false;

    player.swing = false;
    player.swingTimer = 0;
    player.swingAge = 999;
    player.swingPoseTimer = 0;
    player.swingCD = 0;
    player.swingConsumed = false;
    lastAimInit = false;
    aimStillT = 0;
  }

  function startDerby(){
    resetRun(); // keeps player tuning consistent
    resetDerby();
    setMode("derby");
    startCountdown();
  }

  function handleRestartPress(){
    if (gameMode === "story") { resetRun(); startCountdown(); return; }
    if (gameMode === "derby") { resetDerby(); startCountdown(); return; }
    // menu => no-op
  }

  bindMenuSelect(btnStory, startStory);
  bindMenuSelect(btnDerby, startDerby);


  // Aim spot
  const aim = { nx: 0, ny: 0 };
  let lastZone = { x:0, y:0, w:100, h:100 };

  function clampAimToExpandedZone(zone, px, py){
    const ex = zone.x - CHASE_MARGIN;
    const ey = zone.y - CHASE_MARGIN;
    const ew = zone.w + CHASE_MARGIN*2;
    const eh = zone.h + CHASE_MARGIN*2;

    const x = clamp(px, ex + AIM_PAD, ex + ew - AIM_PAD);
    const y = clamp(py, ey + AIM_PAD, ey + eh - AIM_PAD);

    const nx = ((x - (ex + AIM_PAD)) / Math.max(1, (ew - AIM_PAD*2))) * 2 - 1;
    const ny = ((y - (ey + AIM_PAD)) / Math.max(1, (eh - AIM_PAD*2))) * 2 - 1;
    aim.nx = clamp(nx, -1, 1);
    aim.ny = clamp(ny, -1, 1);
  }

  function getAimPoint(zone){
    const ex = zone.x - CHASE_MARGIN;
    const ey = zone.y - CHASE_MARGIN;
    const ew = zone.w + CHASE_MARGIN*2;
    const eh = zone.h + CHASE_MARGIN*2;

    const x = ex + AIM_PAD + ((aim.nx + 1) * 0.5) * (ew - AIM_PAD*2);
    const y = ey + AIM_PAD + ((aim.ny + 1) * 0.5) * (eh - AIM_PAD*2);

    return {
      x: clamp(x, ex + AIM_PAD, ex + ew - AIM_PAD),
      y: clamp(y, ey + AIM_PAD, ey + eh - AIM_PAD),
    };
  }

  // Joystick
  const joyEl = document.getElementById("joy");
  const knobEl = document.getElementById("joyKnob");
  let joyActive = false;
  let joyPid = -1;

  function setKnob(dx, dy){
    knobEl.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
  }

  function updateAimFromJoyPointer(clientX, clientY){
    const r = joyEl.getBoundingClientRect();
    const cx = r.left + r.width/2;
    const cy = r.top + r.height/2;

    const maxR = (Math.min(r.width, r.height) * 0.5) - 18;
    let dx = clientX - cx;
    let dy = clientY - cy;

    const d = Math.hypot(dx, dy) || 1;
    if (d > maxR){
      dx = dx / d * maxR;
      dy = dy / d * maxR;
    }

    aim.nx = clamp(dx / maxR, -1, 1);
    aim.ny = clamp(dy / maxR, -1, 1);

    setKnob(dx, dy);
  }

  joyEl.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    joyActive = true;
    joyPid = e.pointerId;
    joyEl.setPointerCapture(joyPid);
    updateAimFromJoyPointer(e.clientX, e.clientY);
  });

  joyEl.addEventListener("pointermove", (e) => {
    if (!joyActive || e.pointerId !== joyPid) return;
    e.preventDefault();
    updateAimFromJoyPointer(e.clientX, e.clientY);
  });

  function endJoy(e){
    if (!joyActive || e.pointerId !== joyPid) return;
    e.preventDefault();
    joyActive = false;
    joyPid = -1;
  }
  joyEl.addEventListener("pointerup", endJoy);
  joyEl.addEventListener("pointercancel", endJoy);
  joyEl.addEventListener("lostpointercapture", () => { joyActive = false; joyPid = -1; });

  // PC mouse aim + click swing

  canvas.addEventListener("pointermove", (e) => {
    if (e.pointerType !== "mouse") return;
    if (gameMode === "menu") return;
    if (upgradeOpen) return;

    const p = screenToWorld(e.clientX, e.clientY, canvas);
    let mx = p.x;
    let my = p.y;

    if (gameMode === "derby"){
      const wpt = derbyScreenToWorld(mx, my, DESIGN_W, DESIGN_H);
      mx = wpt.x; my = wpt.y;
    }
      clampAimToExpandedZone(lastZone, mx, my);
});

  canvas.addEventListener("pointerdown", (e) => {
    if (e.pointerType !== "mouse") return;
    if (gameMode === "menu") return;
    if (upgradeOpen) return;
    if (e.button === 0) input.swing = true;
  });

  // Game state
  const topbar = document.getElementById("topbar");

  let score = 0;
  let hp = HP_START;

  let combo = 0;
  let comboTimer = 0;
  const COMBO_DECAY = 2.25;

  function getMult(){
    return Math.min(6, 1 + Math.floor(combo / 10));
  }

  let hitStop = 0;
  let shakeT = 0;
  let shakeMag = 0;

  let fxVertT = 0;
  let fxHorzT = 0;

  const buffs = { slowmo:0, double:0, magnet:0, shield:0 };

  const upgrades = {
    hitboxBonus: 0,
    cdMul: 1.0,
    perfectBonus: 0.00,
    skillDamageBonus: 0,

    autoPitchCount: 0,
    autoPitchInterval: 5.0,
    autoPitchT: 0,
  };

  const shots = [];
  const balls = [];
  const bossPitches = [];
  const returns = [];
  const explosions = [];
  const pickups = [];
  const popups = [];

  let spawnT = 0;
  let swingToken = 0;
  let popupStackI = 0;

  let aimStillT = 0;
  let lastAimNX = 0;
  let lastAimNY = 0;

  // Boss
  const boss = {
    alive: false,
    x: 0, y: 0,
    r: 86,
    hp: 0,
    maxHp: 0,
    shootT: 0,
    shootInterval: 0.95,
  };

  // Levels
  let level = 1;
  let levelKills = 0;
  let levelTime = 0;
  let levelBannerT = 1.4;

  const LEVEL_PATTERN = [
    { type:"kills", target:8 },
    { type:"survive", target:18 },
    { type:"kills", target:14 },
    { type:"survive", target:24 },
    { type:"boss", target:1 },
  ];

  const THEME_ORDER = ["alley", "subway", "emoji"];

  const LEVELS = THEME_ORDER.flatMap((theme) =>
    LEVEL_PATTERN.map((s) => ({ ...s, theme }))
  );

  function getLevelSpec(lv){
    const base = LEVELS[(lv-1) % LEVELS.length];
    const tier = Math.floor((lv-1) / LEVELS.length);
    const scale = 1 + tier * 0.20;

    const spec = { ...base };
    if (spec.type === "kills") spec.target = Math.round(spec.target * scale);
    if (spec.type === "survive") spec.target = Math.round(spec.target * scale);
    if (spec.type === "boss") spec.target = 1;

    if (spec.type === "kills") spec.banner = `LEVEL ${lv} — Protect the Plate: ${spec.target} KOs`;
    if (spec.type === "survive") spec.banner = `LEVEL ${lv} — Hold the Line: ${spec.target}s`;
    if (spec.type === "boss") spec.banner = `LEVEL ${lv} — BOSS: HIT IT BACK`;
    return spec;
  }

  function getTheme(lv){
    return LEVELS[(lv-1) % LEVELS.length].theme;
  }

  function difficultyT(){
    return clamp01((level - 1) / 18);
  }

  // Upgrade modal
  const upgradeModal = document.getElementById("upgradeModal");
  const upgradeChoicesEl = document.getElementById("upgradeChoices");
  const upgradeTitle = document.getElementById("upgradeTitle");
  const upgradeSub = document.getElementById("upgradeSub");
  const upgradeTip = document.getElementById("upgradeTip");

  let upgradeOpen = false;
  let pendingNextLevel = null;

  const UPGRADE_CATALOG = {
    hitbox_plus: { name:"Bigger Sweet Spot", desc:"+20px bat contact radius (easier hits).", apply(){ upgrades.hitboxBonus += 20; } },
    autopitch_2: { name:"Auto Pitch", desc:"Every 5s throw 2 friendly balls.", apply(){ upgrades.autoPitchCount = Math.max(upgrades.autoPitchCount, 2); } },
    cooldown:    { name:"Quick Hands", desc:"Skill cooldowns -10%.", apply(){ upgrades.cdMul *= 0.90; } },
  hp: {
    name: "Extra Heart",
    desc: `+1 HP (cap ${HP_MAX}).`,
    apply() { hp = Math.min(HP_MAX, hp + 1); }
  },
    shield:      { name:"Shield Charge", desc:"+1 shield (cap 3).", apply(){ buffs.shield = Math.min(3, buffs.shield + 1); } },
    perfect:     { name:"Timing Master", desc:"Perfect window +0.02s.", apply(){ upgrades.perfectBonus += 0.02; } },
    skill_dmg:   { name:"Sharper Skills", desc:"VERT/HORZ damage +1.", apply(){ upgrades.skillDamageBonus += 1; } },
    autopitch_3: { name:"Auto Pitch+", desc:"Auto Pitch now fires 3 balls.", apply(){ upgrades.autoPitchCount = Math.max(upgrades.autoPitchCount, 3); } },
    autopitch_faster:{ name:"Rapid Pitch", desc:"Auto Pitch interval -1s (min 2s).", apply(){ upgrades.autoPitchInterval = Math.max(2.0, upgrades.autoPitchInterval - 1.0); } },
  };

  function getLevelUpgradeChoices(lv){
    if (lv === 1) return ["hitbox_plus"];
    if (lv === 2) return ["autopitch_2"];

    const pool = ["hitbox_plus","cooldown","hp","shield","perfect","skill_dmg","autopitch_3","autopitch_faster"];
    const weighted = pool.slice();
    if (upgrades.autoPitchCount > 0) weighted.push("autopitch_3","autopitch_faster");

    const pick = [];
    while (pick.length < 3){
      const id = weighted[(Math.random()*weighted.length)|0];
      if (!pick.includes(id)) pick.push(id);
    }
    return pick;
  }

  function openUpgradeModal(nextLv){
    upgradeOpen = true;
    pendingNextLevel = nextLv;

    const choices = getLevelUpgradeChoices(level);
    upgradeTitle.textContent = `Level ${level} Complete!`;
    upgradeSub.textContent = (choices.length === 1) ? "Upgrade unlocked. Tap to continue." : "Pick your upgrade.";
    upgradeTip.textContent = (choices.length === 1) ? "Tap the card to continue." : "Tip: press 1 / 2 / 3 on keyboard (or tap a card).";

    upgradeChoicesEl.innerHTML = choices.map((id, idx) => {
      const u = UPGRADE_CATALOG[id];
      const keyHint = (choices.length === 1) ? "" : `(${idx+1})`;
      return `
        <div class="upg" data-upg="${id}" data-idx="${idx}">
          <div class="n">${u?.name ?? id}</div>
          <div class="d">${u?.desc ?? ""}</div>
          <div class="k">${keyHint}</div>
        </div>
      `;
    }).join("");

    upgradeModal.hidden = false;
  }

  function closeUpgradeModal(){
    upgradeOpen = false;
    upgradeModal.hidden = true;
  }

  function chooseUpgradeByIndex(i){
    const el = upgradeChoicesEl.querySelector('.upg[data-idx="' + i + '"]');
    if (!el) return;
    const id = el.dataset.upg;

    UPGRADE_CATALOG[id]?.apply?.();

    buffs.double = Math.max(buffs.double, 1.2);
    shakeMag = Math.max(shakeMag, 9);
    shakeT = Math.max(shakeT, 0.22);

    closeUpgradeModal();
    startLevel(pendingNextLevel);
    startCountdown();
    pendingNextLevel = null;
  }

  upgradeChoicesEl.addEventListener("pointerup", (e) => {
    const card = e.target.closest(".upg");
    if (!card) return;
    chooseUpgradeByIndex(Number(card.dataset.idx));
  });

  // FX
  function spawnExplosion(x, y, big=false){
    explosions.push({ x, y, frame:0, t:0, fps:24, frameCount:5, size: big ? 120 : 96, alive:true });
  }

  function spawnPopupStacked(anchorX, anchorY, text, kind){
    const offX = stackOffset(popupStackI++);
    popups.push({ x: anchorX + offX, y: anchorY, vy: POPUP_RISE, t: 0, life: POPUP_LIFE, text, kind, alive: true });
  }

  function maybeDropPickup(x, y){
    const p = 0.08 + Math.min(0.06, combo / 200);
    if (Math.random() > p) return;

    const roll = Math.random();
    let type = "double";
    if (roll < 0.25) type = "slowmo";
    else if (roll < 0.50) type = "double";
    else if (roll < 0.75) type = "magnet";
    else type = "shield";

    pickups.push({ x, y, r:18, vy:-240, t:0, type, alive:true });
  }

  function applyPickup(type){
    if (type === "slowmo") buffs.slowmo = Math.max(buffs.slowmo, 3.0);
    if (type === "double") buffs.double = Math.max(buffs.double, 5.0);
    if (type === "magnet") buffs.magnet = Math.max(buffs.magnet, 5.0);
    if (type === "shield") buffs.shield = Math.min(3, buffs.shield + 1);

    shakeMag = Math.max(shakeMag, 4);
    shakeT = Math.max(shakeT, 0.12);
  }

  function endSwingImmediately(){
    player.swing = false;
    player.swingTimer = 0;
    player.swingAge = 999;
  }

  // Swing
  function startSwing(){
    // No cooldown: allow spam swings, but still press-to-swing (no hold)
    swingToken++;
    popupStackI = 0;

    player.swingConsumed = false;

    player.swing = true;
    player.swingTimer = player.swingWindow;
    player.swingAge = 0;
    player.swingPoseTimer = player.swingPoseDur;
    // player.swingCD intentionally unused (no cooldown)
  }

  function applyPlateDamage(amount){
    if (buffs.shield > 0) buffs.shield--;
    else hp = Math.max(0, hp - amount);

    combo = 0;
    comboTimer = 0;

    shakeMag = Math.max(shakeMag, 10);
    shakeT = Math.max(shakeT, 0.20);
  }

  // Auto Pitch (friendly) — in boss fight: only homes to BOSS
  const SHOT_HOMING = true;
  const SHOT_HOMING_RANGE = 1200;
  const SHOT_TURN_RATE = 14;
  const SHOT_LEAD_TIME = 0.20;

  function acquireShotTarget(s){
    if (boss.alive) return boss;
    let best = null;
    let bestScore = -Infinity;
    for (const b of balls){
      if (!b.alive) continue;
      const d = Math.hypot(b.x - s.x, b.y - s.y);
      if (d > SHOT_HOMING_RANGE) continue;
      const score = -d + (b.toPlateDist ? (-b.toPlateDist * 0.04) : 0);
      if (score > bestScore){ bestScore = score; best = b; }
    }
    return best;
  }

  function fireAutoPitch(W, H){
    if (upgrades.autoPitchCount <= 0) return;

    const band = getContactBandFromPlate(W, H);
    const cx = band.x + band.w/2;
    const cy = band.y + band.h/2;

    const startX = cx + (player.facing === 1 ? -22 : 22);
    const startY = cy + 30;

    for (let i = 0; i < upgrades.autoPitchCount; i++){
      const spread = (i - (upgrades.autoPitchCount-1)/2) * 22;
      shots.push({
        x: startX,
        y: startY + spread,
        r: 14,
        speed: 920,
        vx: (player.facing === 1 ? 920 : -920),
        vy: 0,
        homing: true,
        target: null,
        alive: true,
        dmg: 1,
      });
    }
  }

  function bossDamage(dmg, isPerfect=false){
    boss.hp = Math.max(0, boss.hp - dmg);

    hitStop = isPerfect ? 0.09 : 0.06;
    shakeMag = Math.max(shakeMag, isPerfect ? 16 : 12);
    shakeT = Math.max(shakeT, 0.22);

    spawnExplosion(boss.x, boss.y + boss.r * 0.1, isPerfect);

    if (boss.hp <= 0){
      boss.alive = false;
      levelKills = 1;
      finishLevel();
    }
  }

  function updateShots(dt, W, H){
    for (const s of shots){
      if (!s.alive) continue;

      if (SHOT_HOMING && s.homing){
        if (!s.target || (s.target !== boss && !s.target.alive)) s.target = acquireShotTarget(s);

        if (s.target){
          const tx = s.target.x + (s.target.vx || 0) * SHOT_LEAD_TIME;
          const ty = s.target.y + (s.target.vy || 0) * SHOT_LEAD_TIME;

          const desired = norm2(tx - s.x, ty - s.y);
          const cur = norm2(s.vx, s.vy);

          const t = clamp01(SHOT_TURN_RATE * dt);
          const nx = cur.x + (desired.x - cur.x) * t;
          const ny = cur.y + (desired.y - cur.y) * t;
          const nd = norm2(nx, ny);

          s.vx = nd.x * (s.speed || 920);
          s.vy = nd.y * (s.speed || 920);
        }
      }

      s.x += s.vx * dt;
      s.y += s.vy * dt;

      if (s.x > W + 120 || s.x < -120 || s.y > H + 120 || s.y < -120) s.alive = false;

      if (boss.alive){
        const d = Math.hypot(s.x - boss.x, s.y - boss.y);
        if (d <= boss.r * 0.72 + s.r){
          s.alive = false;
          bossDamage(s.dmg, false);
          continue;
        }
        continue;
      }

      for (const b of balls){
        if (!b.alive) continue;
        const dx = b.x - s.x, dy = b.y - s.y;
        const rr = (b.r + s.r);
        if ((dx*dx + dy*dy) <= rr*rr){
          s.alive = false;
          b.hp -= s.dmg;
          hitStop = 0.06;
          shakeMag = Math.max(shakeMag, 10);
          shakeT = Math.max(shakeT, 0.18);
          spawnExplosion(b.x, b.y, false);
          if (b.hp <= 0) b.alive = false;
          break;
        }
      }
    }

    for (let i = shots.length - 1; i >= 0; i--){
      if (!shots[i].alive) shots.splice(i, 1);
    }
  }

  function spawnEnemy(W, H, zone, expandedZone, kind="normal"){
    const speedScale = 1 + (level-1) * 0.06;

    let r = 42, hpv = 1, scoreV = 10, spd = (280 + Math.random()*120) * speedScale;

    let wobMag = 18;
    let wobSpeed = 8;

    if (kind === "fast"){
      r = 30; hpv = 1; scoreV = 18;
      spd = (380 + Math.random()*160) * speedScale;
      wobMag = 28;
      wobSpeed = 12;
    }

    if (kind === "heavy"){
      r = 52; hpv = 1; scoreV = 25;
      spd = (240 + Math.random()*110) * speedScale;
      wobMag = 16;
      wobSpeed = 7;
    }

    if (kind === "sandwich"){
      r = 56; hpv = 1; scoreV = 34;
      spd = (300 + Math.random()*140) * speedScale;
      wobMag = 110;
      wobSpeed = 20;
    }

    const lane = (Math.random() * 3) | 0;
    let x, y;
    if (lane === 0){ x = Math.random()*W; y = -80; }
    else if (lane === 1){ x = -80; y = Math.random()*(H*0.62); }
    else { x = W + 80; y = Math.random()*(H*0.62); }

    balls.push({
      kind, x, y, r,
      alive:true,
      hp: hpv,
      scoreV,
      speed: spd,
      vx:0, vy:0,

      wobPhase: Math.random()*Math.PI*2,
      wobMag,
      wobSpeed,
      zigzag: (kind === "sandwich"),

      targetX: pickApproachX(zone, expandedZone),
      retargeted: false,

      toPlateDist: 9999,
      lastHitSwingToken: -1,
      pendingPlate: false,

      playerSwung: false,
      justHitT: 0,
    crossedZone: false,
      swungAt: false,
    });
  }

  function dealDamageToEnemyBall(b, dmg, {isPerfect=false, fromSkill=false} = {}){
    if (!b.alive) return false;

    b.hp -= dmg;

    hitStop = fromSkill ? 0.06 : (isPerfect ? 0.085 : 0.045);
    shakeMag = Math.max(shakeMag, fromSkill ? 12 : (isPerfect ? 14 : 9));
    shakeT = Math.max(shakeT, fromSkill ? 0.20 : (isPerfect ? 0.22 : 0.16));

    if (b.hp > 0){
      combo++;
      comboTimer = COMBO_DECAY;
      score += Math.round(6 * getMult() * (buffs.double > 0 ? 2 : 1));
      spawnExplosion(b.x, b.y, false);
      return true;
    }

    b.alive = false;

    combo++;
    comboTimer = COMBO_DECAY;

    const mult = getMult();
    const bonus = isPerfect ? 1.35 : 1.0;
    const doubleOn = (buffs.double > 0) ? 2 : 1;

    score += Math.round(b.scoreV * mult * bonus * doubleOn);
    levelKills++;

    spawnExplosion(b.x, b.y, isPerfect || fromSkill);
    maybeDropPickup(b.x, b.y);

    const spec = getLevelSpec(level);
    if (!upgradeOpen && spec.type === "kills" && levelKills >= spec.target) finishLevel();
    return true;
  }

  // Boss pitch types
  const BOSS_PITCH_TYPES = [
    { id:"FASTBALL", speedMul:1.18, curve:0.0,  sink:0.00, lateBreak:0.00 },
    { id:"CURVE",    speedMul:0.96, curve:1.0,  sink:0.14, lateBreak:0.25 },
    { id:"SLIDER",   speedMul:1.05, curve:0.7,  sink:0.06, lateBreak:0.55 },
    { id:"SINKER",   speedMul:1.02, curve:0.25, sink:0.34, lateBreak:0.62 },
    { id:"CHANGE",   speedMul:0.84, curve:0.35, sink:0.10, lateBreak:0.40 },
  ];

  function pickBossPitchType(){
    const t = difficultyT();
    const early = [0,0,0,1,4];
    const mid   = [0,1,2,3,4];
    const late  = [0,1,2,2,3,3,4];
    const pool = (t < 0.33) ? early : (t < 0.70) ? mid : late;
    return BOSS_PITCH_TYPES[pool[(Math.random()*pool.length)|0]];
  }

  function startBossFight(W, H){
    const t = difficultyT();
    boss.alive = true;
    boss.maxHp = Math.round(14 + level * 1.4);
    boss.hp = boss.maxHp;

    boss.x = W * 0.5;
    boss.y = Math.max(88, H * lerp(0.16, 0.20, t));
    boss.r = 86;

    boss.shootT = 0;
    boss.shootInterval = lerp(1.05, 0.62, t);
  }

  function spawnBossPitch(W, H, zone, band){
    const plate = getPlate(W, H);
    const t = difficultyT();

    const pt = pickBossPitchType();
    const r = 32 + Math.random() * 7;

    const baseSpeed = lerp(360, 560, t);
    const spd = baseSpeed * pt.speedMul + Math.random() * 35;

    const ballChance = lerp(0.18, 0.30, t);
    const isBallPitch = Math.random() < ballChance;

    const targetY = band.y + band.h/2;

    const strikeX = zone.x + 14 + Math.random() * (zone.w - 28);
    const ballX = plate.x + (Math.random() < 0.5 ? -1 : 1) * (zone.w * 0.65 + 50 + Math.random() * 120);
    const targetX = isBallPitch ? ballX : strikeX;

    const dir = norm2(targetX - boss.x, targetY - boss.y);
    const breakSign = (Math.random() < 0.5) ? -1 : 1;

    bossPitches.push({
      x: boss.x,
      y: boss.y + boss.r * 0.25,
      r,
      alive: true,
      hp: 1,
      speed: spd,
      vx: dir.x * spd,
      vy: dir.y * spd,

      pitchId: pt.id,
      curveK: pt.curve * breakSign,
      sinkK: pt.sink,
      lateBreak: pt.lateBreak,

      phase: Math.random() * Math.PI * 2,
      isBallPitch,
      toPlateDist: 9999,
      lastHitSwingToken: -1,
      pendingPlate: false,
      labelT: 0.75,
      crossedZone: false,
      swungAt: false,
    });
  }

  function applyBossPitchMovement(p, dt){
    const prog = clamp01(1 - (p.toPlateDist / 520));
    const late = clamp01((prog - p.lateBreak) / Math.max(0.0001, (1 - p.lateBreak)));

    p.phase += dt * 7.0;
    const wob = Math.sin(p.phase);

    const vdir = norm2(p.vx, p.vy);
    const perp = { x: -vdir.y, y: vdir.x };

    const curveMag = (18 + 32 * late) * (p.curveK || 0) * (0.65 + 0.35 * wob);
    p.vx += perp.x * curveMag * dt;
    p.vy += perp.y * curveMag * dt;

    const sinkMag = (65 * late) * (p.sinkK || 0);
    p.vy += sinkMag * dt;

    const nd = norm2(p.vx, p.vy);
    p.vx = nd.x * p.speed;
    p.vy = nd.y * p.speed;
  }

  function createReturnBall(fromX, fromY, grade, aimPt, zone, timing01){
    const timing = clamp((0.5 - timing01) * 2, -1, 1);

    const zoneCx = zone.x + zone.w/2;
    const zoneCy = zone.y + zone.h/2;

    const ax = (aimPt.x - zoneCx) / Math.max(1, zone.w/2);
    const ay = (aimPt.y - zoneCy) / Math.max(1, zone.h/2);

    const pullX = player.facing * timing * 180;
    const aimX = clamp(ax, -1, 1) * 150;
    const aimY = clamp(ay, -1, 1) * 70;

    const targetX = boss.x + pullX + aimX;
    const targetY = boss.y + aimY;

    const dir = norm2(targetX - fromX, targetY - fromY);

    const isPerfect = grade === "perfect";
    const dmg = isPerfect ? 2 : 1;

    const speed =
      isPerfect ? 980 :
      (grade === "good" ? 920 : 860);

    returns.push({
      x: fromX,
      y: fromY,
      r: 14,
      vx: dir.x * speed,
      vy: dir.y * speed,
      alive: true,
      dmg,
      isPerfect,
    });
  }

  function updateBossFight(dt, W, H, zone, band, swingActive, expandedZone){
    if (!boss.alive) return;

    const tx = band.x + band.w/2;
    const ty = band.y + band.h/2;

    boss.shootT += dt;
    if (boss.shootT >= boss.shootInterval){
      boss.shootT = 0;
      spawnBossPitch(W, H, zone, band);

      const t = difficultyT();
      if (t > 0.55 && Math.random() < 0.22){
        spawnBossPitch(W, H, zone, band);
      }
    }

    for (const p of bossPitches){
      if (!p.alive) continue;

      p.labelT = Math.max(0, p.labelT - dt);


      if (!p.crossedZone && circleRectHit(p.x, p.y, p.r, zone.x, zone.y, zone.w, zone.h)) p.crossedZone = true;
      applyBossPitchMovement(p, moveDt);

      p.x += p.vx * moveDt;
      p.y += p.vy * moveDt;

      p.toPlateDist = Math.hypot(tx - p.x, ty - p.y);

      if (p.pendingPlate) continue;

      if (p.y + p.r >= band.bot){
        const hittableNow = swingActive && !player.swingConsumed &&
          circleRectHit(p.x, p.y, p.r, derbyHitZone.x, derbyHitZone.y, derbyHitZone.w, derbyHitZone.h);

        if (hittableNow){
          p.pendingPlate = true;
          p.y = band.bot - p.r - PLATE_HOLD_EPS;
          continue;
        }

        p.alive = false;
        const hitsPlateLane = circleRectHit(p.x, p.y, p.r, band.x, band.y, band.w, band.h);
        if (hitsPlateLane && p.crossedZone){
          applyPlateDamage(1);
          spawnPopupStacked(p.x, band.y - 18, "STRIKE!", "strike");
        } else if (hitsPlateLane && !p.crossedZone){
          spawnPopupStacked(p.x, band.y - 18, "BALL", "ball");
        }
      }
    }

    for (const r of returns){
      if (!r.alive) continue;

      r.x += r.vx * dt;
      r.y += r.vy * dt;

      if (r.x < -200 || r.x > W + 200 || r.y < -200 || r.y > H + 200){
        r.alive = false;
        continue;
      }

      const d = Math.hypot(r.x - boss.x, r.y - boss.y);
      if (d <= (boss.r * 0.72 + r.r)){
        r.alive = false;
        bossDamage(r.dmg, r.isPerfect);
      }
    }

    for (let i = bossPitches.length - 1; i >= 0; i--) if (!bossPitches[i].alive) bossPitches.splice(i, 1);
    for (let i = returns.length - 1; i >= 0; i--) if (!returns[i].alive) returns.splice(i, 1);
  }

  
  // Home Run Derby helpers
  function drawImageCover(img, W, H){
    const ar = img.width / img.height;
    const tr = W / H;
    let dw, dh, dx, dy;
    if (ar > tr){ dh = H; dw = H * ar; dx = (W - dw)/2; dy = 0; }
    else { dw = W; dh = W / ar; dx = 0; dy = (H - dh)/2; }
    ctx.drawImage(img, dx, dy, dw, dh);
  }

  function getPitcherRect(W, H){
    // Derby pitcher placement: anchored to strike zone but with tunable "back" + size.
    const z = lastZone || getStrikeZoneFromPlate(W, H);

    const base = Math.min(320, Math.max(200, W * 0.24));
    const w = base * DERBY_PITCHER_SIZE_SCALE;
    const h = w;

    const cx = (z.x + z.w/2) + DERBY_PITCHER_X_OFFSET;
    const back = (0.95 * DERBY_PITCHER_BACK_MULT);
    const y = clamp((z.y - h * back) + DERBY_PITCHER_Y_OFFSET, 10, H - h - 10);
    const x = clamp(cx - w/2, 10, W - w - 10);
    return { x, y, w, h };
  }

  function getPitcherReleasePoint(W, H){
    const pr = getPitcherRect(W, H);
    return { x: pr.x + pr.w * 0.74, y: pr.y + pr.h * 0.52 };
  }

  function spawnDerbyPitch(W, H, zone, band){
    const t = difficultyT();

    const pt = pickBossPitchType();
    const r0 = 6 + Math.random() * 2;   // small (far)
    const r1 = 18 + Math.random() * 4;  // big (near)

    const baseSpeed = lerp(520, 720, t);
    const spd = baseSpeed * pt.speedMul + Math.random() * 30;

    const ballChance = lerp(0.14, 0.22, t);
    const isBallPitch = Math.random() < ballChance;

    const plate = getPlate(W, H);
    const from = getPitcherReleasePoint(W, H);

    // Two-phase: pitcher -> (zone level) -> plate (option C)
    const zoneY  = zone.y + zone.h/2;
    const plateY = band.y + band.h/2;

    const strikeX = zone.x + 14 + Math.random() * (zone.w - 28);
    const ballX = plate.x + (Math.random() < 0.5 ? -1 : 1) * (zone.w * 0.60 + 40 + Math.random() * 110);
    const targetX = isBallPitch ? ballX : strikeX;

    const dir0 = norm2(targetX - from.x, zoneY - from.y);
    const breakSign = (Math.random() < 0.5) ? -1 : 1;

    derbyPitches.push({
      x: from.x,
      y: from.y,

      // radius scaling (far -> near)
      r: r0,
      r0,
      r1,

      alive: true,
      speed: spd,
      vx: dir0.x * spd,
      vy: dir0.y * spd,

      // phase + targets
      targetX,
      zoneY,
      plateY,
      passedZoneY: false,

      // used for size lerp
      startX: from.x,
      startY: from.y,

      startDist: Math.hypot((band.x + band.w/2) - from.x, (band.y + band.h/2) - from.y),

      pitchId: pt.id,
      curveK: pt.curve * breakSign,
      sinkK: pt.sink,
      lateBreak: pt.lateBreak,

      phase: Math.random() * Math.PI * 2,
      isBallPitch,
      toPlateDist: 9999,
      lastHitSwingToken: -1,
      pendingPlate: false,

      // strike/ball classification: did it ever enter the strike box?
      crossedZone: false,
      swungAt: false,
    });

    derby.pitches += 1;
  }

  function createDerbyBattedBall(fromX, fromY, grade, aimPt, zone, timing01, W, H){
    const timing = clamp((0.5 - timing01) * 2, -1, 1);

    const zoneCx = zone.x + zone.w/2;
    const zoneCy = zone.y + zone.h/2;
    const ax = (aimPt.x - zoneCx) / Math.max(1, zone.w/2);
    const ay = (aimPt.y - zoneCy) / Math.max(1, zone.h/2);

    const pullX = player.facing * timing * 280;
    const aimX = clamp(ax, -1, 1) * 220;
    const aimY = clamp(ay, -1, 1) * 60;

    const isHR = grade === "perfect";

    const tx = (isHR ? (W * 0.62) : (W * 0.58)) + pullX + aimX;
    const ty = (isHR ? (H * 0.08) : (H * 0.22)) + aimY;

    derbyHits.push({
      alive: true,
      grade,
      t: 0,
      life: (grade === "perfect") ? 1.55 : 1.25,
      arcMag: (grade === "perfect") ? 320 : 220,
      sx: fromX,
      sy: fromY,
      tx,
      ty,
      x: fromX,
      y: fromY,
      r: 14,
    });
  }

  function updateDerbyHits(dt){
    for (const h of derbyHits){
      if (!h.alive) continue;
      h.t += dt;
      const u = clamp01(h.t / h.life);
      const arc = Math.sin(u * Math.PI) * (h.arcMag || 220);
      h.x = lerp(h.sx, h.tx, u);
      h.y = lerp(h.sy, h.ty, u) - arc;
      h.r = lerp(14, 7, u);

      if (u >= 1) h.alive = false;
    }
    for (let i = derbyHits.length - 1; i >= 0; i--) if (!derbyHits[i].alive) derbyHits.splice(i, 1);
  }

  function applyDerbyPitchResult(p, band){
    const hitsPlateLane = circleRectHit(p.x, p.y, p.r, band.x, band.y, band.w, band.h);
    if (!hitsPlateLane) return;

    // Strike if it crossed the zone OR you swung (even at a ball) and missed.
    const isStrike = !!p.crossedZone || !!p.swungAt;

    if (isStrike){
      derby.strikes += 1;
      derby.hp = Math.max(0, derby.hp - 1);

      spawnPopupStacked(p.x, band.y - 18, "STRIKE!", "strike");

      if (derby.strikes >= 3 || derby.hp <= 0) derby.over = true;
    } else {
      derby.balls += 1;
      spawnPopupStacked(p.x, band.y - 18, "BALL", "ball");
    }
  }

  function updateDerbyHUD(){
    topbar.textContent =
      `HOME RUN DERBY • ${player.stance.toUpperCase()}\n` +
      `HR ${derby.homeruns} • Pitches ${derby.pitches}
` +
      `Strikes ${derby.strikes}/3 • Balls ${derby.balls}`;
  }
// Derby aim tracking (needed by stepDerby)
let lastAimPt = { x: 0, y: 0 };
let lastAimInit = false;

  function stepDerby(dt, W, H){
    if (!derby.active) resetDerby();
    if (upgradeOpen) return;

    // base timers / effects
    if (shakeT > 0){
      shakeT = Math.max(0, shakeT - dt);
      if (shakeT <= 0){ shakeT = 0; shakeMag = 0; }
    }

    // Perfect-hit hit-stop (freeze frame)
    if (derby.hitStop > 0){
      derby.hitStop = Math.max(0, derby.hitStop - dt);
      return;
    }

    if (derby.slowmoT > 0) derby.slowmoT = Math.max(0, derby.slowmoT - dt);
    const moveDt = dt * ((derby.slowmoT > 0) ? 0.55 : 1.0);

    const sdt = dt; // swing math must match Story

// Update popups (shared)
    for (const p of popups){
      p.t += moveDt;
    }
    for (let i = popups.length - 1; i >= 0; i--) if (popups[i].t >= popups[i].life) popups.splice(i, 1);

    const plate = getPlate(W, H);
    const band  = getContactBandFromPlate(W, H);

    // Anchor batter to plate in Derby (consistent with Story)
    const bandCx = band.x + band.w / 2;
    const playerCenterX = bandCx + (player.stance === "righty" ? -STANCE_OFFSET : STANCE_OFFSET) + DERBY_BATTER_X_OFFSET;
    player.x = playerCenterX - player.w/2;
    player.y = clamp((plate.y - player.h + 14) + DERBY_BATTER_Y_OFFSET, 0, H - player.h - 10);
    let zone = getStrikeZoneFromPlate(W, H);
    lastZone = zone;

    const expandedZone = {
      x: zone.x - CHASE_MARGIN,
      y: zone.y - CHASE_MARGIN,
      w: zone.w + CHASE_MARGIN*2,
      h: zone.h + CHASE_MARGIN*2,
    };

    // Derby contact area: tight to the strike zone so you can't "hit anything anywhere"
    derbyHitZone = { x: zone.x - 30, y: zone.y - 30, w: zone.w + 60, h: zone.h + 60 };


    // Derby grading tuning (kept separate from Story so Story stays untouched)
    // (uses global DERBY_* tuning constants)
    const aimPt = getAimPoint(zone);
    const aimDx = aimPt.x - lastAimPt.x;
    const aimDy = aimPt.y - lastAimPt.y;
    if (Math.hypot(aimDx, aimDy) <= AIM_STILL_EPS * Math.max(W, H)){
      aimStillT = Math.min(AIM_STILL_T_FULL + 1, aimStillT + dt);
    } else {
      aimStillT = 0;
      lastAimPt.x = aimPt.x;
      lastAimPt.y = aimPt.y;
    }
    const aimPenalty01 = clamp01((aimStillT - AIM_STILL_T_START) / Math.max(0.0001, (AIM_STILL_T_FULL - AIM_STILL_T_START)));
    const baseBatR = BAT_R_BASE + upgrades.hitboxBonus * BAT_R_PER_UPG;
    const batR = baseBatR * (1 - AIM_PENALTY_BAT_SHRINK * aimPenalty01);

// swing input + timers (match Story)
// - press to swing (no hold), spam allowed
if (input.swing){
  startSwing();

  // Mark a swing attempt so a "ball" becomes a strike if you whiff.
  // (Only if the pitch is actually in/near the strike zone area.)
  const attempt = { x: zone.x - 30, y: zone.y - 30, w: zone.w + 60, h: zone.h + 60 };
  for (const p of derbyPitches){
    if (!p.alive) continue;
    if (circleRectHit(p.x, p.y, p.r, attempt.x, attempt.y, attempt.w, attempt.h)){
      p.swungAt = true;
    }
  }
}
input.swing = false;

    if (player.swing){
      player.swingTimer = Math.max(0, player.swingTimer - sdt);
      player.swingAge += sdt;
      player.swingPoseTimer = Math.max(0, player.swingPoseTimer - sdt);
      if (player.swingTimer <= 0) player.swing = false;
    } else {
      player.swingAge = Math.min(999, player.swingAge + sdt);
      player.swingPoseTimer = Math.max(0, player.swingPoseTimer - sdt);
    }

    const swingActive = (player.swing || player.swingAge <= player.swingWindow + LATE_GRACE);

    // Pitcher pose / pitch spawn
    if (!derby.over){
      derby.poseT += dt;
      if (derby.pose === "windup" && derby.poseT >= derby.windupDur){
        derby.pose = "release";
        derby.poseT = 0;
        if (derbyPitches.length === 0) spawnDerbyPitch(W, H, zone, band);
      } else if (derby.pose === "release" && derby.poseT >= derby.releaseDur){
        derby.pose = "follow";
        derby.poseT = 0;
      } else if (derby.pose === "follow" && derby.poseT >= derby.followDur){
        derby.pose = "windup";
        derby.poseT = 0;
      }
    }

    // Update pitches
    const tx = band.x + band.w/2;
    const ty = band.y + band.h/2;

    for (const p of derbyPitches){
      if (!p.alive) continue;

      if (!p.crossedZone && circleRectHit(p.x, p.y, p.r, zone.x, zone.y, zone.w, zone.h)) p.crossedZone = true;

      // phase switch at strike-zone level: pitcher -> zoneY -> plate
      if (!p.passedZoneY && p.y >= p.zoneY){
        p.passedZoneY = true;
        const dir1 = norm2(p.targetX - p.x, ty - p.y);
        p.vx = dir1.x * p.speed;
        p.vy = dir1.y * p.speed;
      }

      applyBossPitchMovement(p, moveDt);

      p.x += p.vx * moveDt;
      p.y += p.vy * moveDt;

      // radius grows as it approaches the plate
      const progY = clamp01((p.y - p.startY) / Math.max(1, (p.plateY - p.startY)));
      p.r = lerp(p.r0, p.r1, easeOutCubic(progY));

      p.toPlateDist = Math.hypot(tx - p.x, ty - p.y);
      if (p.startDist){
        const prog = clamp01(1 - (p.toPlateDist / Math.max(0.0001, p.startDist)));
        p.r = lerp(p.r0 ?? p.r, p.r1 ?? p.r, easeOutCubic(prog));
      }

      if (p.pendingPlate) continue;

      if (p.y + p.r >= band.bot){
        const hittableNow = swingActive && !player.swingConsumed &&
          circleRectHit(p.x, p.y, p.r, derbyHitZone.x, derbyHitZone.y, derbyHitZone.w, derbyHitZone.h);

        if (hittableNow){
          p.pendingPlate = true;
          p.y = band.bot - p.r - PLATE_HOLD_EPS;
          continue;
        }

        p.alive = false;
        applyDerbyPitchResult(p, band);
      }
    }

    // Swing contact (match Story: one hit per swing, late grace allowed)
    if (swingActive && !player.swingConsumed){
      const baseBatR = BAT_R_BASE + upgrades.hitboxBonus * BAT_R_PER_UPG;
      const batR = baseBatR * (1 - AIM_PENALTY_BAT_SHRINK * aimPenalty01);

      const perfectWindow = DERBY_PERFECT_W;
      const goodWindow    = DERBY_GOOD_W;

      const timing01 = clamp01(player.swingAge / Math.max(0.0001, player.swingWindow));
      const timeGrade =
        (player.swingAge <= perfectWindow) ? "perfect" :
        (player.swingAge <= goodWindow)    ? "good" :
        "normal";

      const thrPerfect = lerp(DERBY_OVERLAP_PERFECT, 0.64, aimPenalty01);
      const thrGood    = lerp(DERBY_OVERLAP_GOOD,    0.62, aimPenalty01);

      let didAnyContact = false;

      for (const b of derbyPitches){
        if (!b.alive) continue;
        if (b.lastHitSwingToken === swingToken) continue;

        const inHittable = circleRectHit(b.x, b.y, b.r, derbyHitZone.x, derbyHitZone.y, derbyHitZone.w, derbyHitZone.h);
        if (!inHittable) continue;

        const d = Math.hypot(b.x - aimPt.x, b.y - aimPt.y);
        const overlapA = circleOverlapArea(b.r, batR, d);
        if (overlapA <= 0) continue;

        const ballA = Math.PI * b.r * b.r;
        const fracBall = overlapA / Math.max(1e-6, ballA);

        // Require meaningful overlap to count as a hit (prevents "spam swing hits everything")
        if (fracBall < DERBY_MIN_CONTACT_FRAC) continue;

        const overlapGrade =
          (fracBall >= thrPerfect) ? "perfect" :
          (fracBall >= thrGood)    ? "good" :
          "normal";

        // Final grade (more forgiving than needing both "perfect"):
        // - perfect: strong overlap + near-perfect timing OR perfect timing + at least good overlap
        // - good: both timing and overlap are at least "good"
        let grade = "normal";
        if (
          (timeGrade === "perfect" && (overlapGrade === "perfect" || overlapGrade === "good")) ||
          (overlapGrade === "perfect" && (timeGrade === "perfect" || timeGrade === "good"))
        ){
          grade = "perfect";
        } else if (timeGrade !== "normal" && overlapGrade !== "normal"){
          grade = "good";
        }
        b.lastHitSwingToken = swingToken;
        b.pendingPlate = false;

        didAnyContact = true;
        b.alive = false;
        // Visualize the contact (perfect flies farther)
        createDerbyBattedBall(b.x, b.y, grade, aimPt, zone, timing01, W, H);

        // Scoring: ONLY perfect hits are Home Runs
        if (grade === "perfect"){
          derby.homeruns += 1;

          spawnPopupStacked(aimPt.x, aimPt.y - 26, "BOOOM!", "perfect");
          spawnPopupStacked(aimPt.x, aimPt.y - 2, "HOMERUN!", "perfect");

          // quick punch + slow-down feel
          derby.hitStop = Math.max(derby.hitStop, 0.06);
          derby.slowmoT = Math.max(derby.slowmoT, 0.25);

          shakeMag = Math.max(shakeMag, 16);
          shakeT = Math.max(shakeT, 0.28);
        } else if (grade === "good"){
          spawnPopupStacked(aimPt.x, aimPt.y - 22, "HIT", "good");
        } else {
          spawnPopupStacked(aimPt.x, aimPt.y - 22, "HIT", "normal");
        }

        // handled above
        if (didAnyContact){
          player.swingConsumed = true;
          endSwingImmediately();
          break;
        }
      }
    }

    // Resolve pending plate-cross AFTER swing
    for (const p of derbyPitches){
      if (!p.alive) continue;
      if (!p.pendingPlate) continue;

      p.pendingPlate = false;
      p.alive = false;
      applyDerbyPitchResult(p, band);
    }

    for (let i = derbyPitches.length - 1; i >= 0; i--) if (!derbyPitches[i].alive) derbyPitches.splice(i, 1);

    updateDerbyHits(moveDt);
    updateDerbyHUD();
  }

  function drawMenu(W, H){ 
    ctx.save();
    const bg = IMG.derbyBg || IMG.bg;
    if (bg) drawImageCover(bg, W, H);
    else { ctx.fillStyle = "#101a3a"; ctx.fillRect(0,0,W,H); }
    ctx.restore();
  }

  function drawDerby(ctx, W, H){
    let camX = 0, camY = 0;
    if (shakeT > 0){
      camX = (Math.random()*2 - 1) * shakeMag;
      camY = (Math.random()*2 - 1) * shakeMag;
    }

    ctx.save();
    ctx.translate(camX, camY);

    const bg = IMG.derbyBg || IMG.bg;
    if (bg) drawImageCover(bg, W, H);
    else { ctx.fillStyle = "#101a3a"; ctx.fillRect(0,0,W,H); }

    // Derby world matches Story pixel-for-pixel (no extra zoom)

    const plate = getPlate(W, H);
    const band  = getContactBandFromPlate(W, H);
    let zone = getStrikeZoneFromPlate(W, H);
    lastZone = zone;

    const aimPt = getAimPoint(zone);
    const aimPenalty01 = clamp01((aimStillT - AIM_STILL_T_START) / Math.max(0.0001, (AIM_STILL_T_FULL - AIM_STILL_T_START)));
    const baseBatR = BAT_R_BASE + upgrades.hitboxBonus * BAT_R_PER_UPG;
    const batR = baseBatR * (1 - AIM_PENALTY_BAT_SHRINK * aimPenalty01);

    // Strike zone
    if (STRIKE_ZONE_VISIBLE){
      ctx.save();
      ctx.globalAlpha = 0.14;
      ctx.fillStyle = "#00ffff";
      ctx.fillRect(zone.x, zone.y, zone.w, zone.h);
      ctx.globalAlpha = 0.92;
      ctx.lineWidth = 4;
      ctx.strokeStyle = "rgba(0,255,255,0.95)";
      ctx.strokeRect(zone.x, zone.y, zone.w, zone.h);

      ctx.globalAlpha = 0.28;
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(255,255,255,0.55)";
      ctx.strokeRect(zone.x - CHASE_MARGIN, zone.y - CHASE_MARGIN, zone.w + CHASE_MARGIN*2, zone.h + CHASE_MARGIN*2);
      ctx.restore();
    }

    // Bat circle
    ctx.save();
    ctx.globalAlpha = 0.20;
    ctx.fillStyle = "rgba(0,0,0,0.60)";
    ctx.beginPath();
    ctx.arc(aimPt.x + 2, aimPt.y + 2, batR, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.08;
    ctx.fillStyle = "rgba(255,255,255,0.90)";
    ctx.beginPath();
    ctx.arc(aimPt.x, aimPt.y, batR, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.90;
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(255,255,255,0.92)";
    ctx.beginPath();
    ctx.arc(aimPt.x, aimPt.y, batR, 0, Math.PI*2);
    ctx.stroke();

    ctx.globalAlpha = 0.70;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(aimPt.x - 14, aimPt.y);
    ctx.lineTo(aimPt.x + 14, aimPt.y);
    ctx.moveTo(aimPt.x, aimPt.y - 14);
    ctx.lineTo(aimPt.x, aimPt.y + 14);
    ctx.stroke();
    ctx.restore();

    // plate marker
    ctx.save();
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.ellipse(plate.x, plate.y + 18, 46, 16, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // Pitcher
    const pr = getPitcherRect(W, H);
    const pimg = (derby.pose === "windup") ? IMG.pitcherWindup : IMG.pitcherPitch;
    if (pimg){
      ctx.save();
      ctx.globalAlpha = 0.55;
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.ellipse(pr.x + pr.w*0.52, pr.y + pr.h*0.88, pr.w*0.26, pr.h*0.10, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.55)";
      ctx.shadowBlur = 14;
      ctx.shadowOffsetY = 6;
      ctx.drawImage(pimg, pr.x, pr.y, pr.w, pr.h);
      ctx.restore();
    }

    // Player (re-use story pose logic)
    const useSwingPose = player.swingPoseTimer > 0;
    const plImg = useSwingPose ? IMG.pSwingFollow : IMG.player;
    if (plImg){
      ctx.save();
      const px = player.x, py = player.y;
      if (player.facing === -1){
        ctx.translate(px + player.w/2, 0);
        ctx.scale(-1, 1);
        ctx.translate(-(px + player.w/2), 0);
      }
      ctx.drawImage(plImg, px, py, player.w, player.h);
      ctx.restore();
    }

    // Batted balls
    const ballImg = IMG.ball;
    for (const h of derbyHits){
      if (!h.alive) continue;
      const size = h.r * 2;
      if (ballImg) ctx.drawImage(ballImg, h.x - h.r, h.y - h.r, size, size);
      else { ctx.beginPath(); ctx.arc(h.x, h.y, h.r, 0, Math.PI*2); ctx.fillStyle = "#fff"; ctx.fill(); }
    }

    // Pitches
    for (const b of derbyPitches){
      if (!b.alive) continue;
      const size = b.r * 2;
      ctx.save();
      ctx.globalAlpha = 0.55;
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.ellipse(b.x, b.y + b.r * 0.60, b.r * 0.92, b.r * 0.42, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      if (ballImg) ctx.drawImage(ballImg, b.x - b.r, b.y - b.r, size, size);
      else { ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fillStyle = "#ff3b3b"; ctx.fill(); }
    }

    // popups (shared draw)
    for (const p of popups){
      const t = clamp01(p.t / p.life);
      const a = 1 - t;
      const bump = 1 + Math.sin(Math.min(1, t) * Math.PI) * 0.20;

      ctx.save();
      ctx.globalAlpha = 0.95 * a;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.shadowColor = "rgba(0,0,0,0.55)";
      ctx.shadowBlur = 10;

      const fontSize = p.kind === "perfect" ? 34 : p.kind === "good" ? 28 : 24;
      ctx.font = `950 ${Math.round(fontSize * bump)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.fillStyle =
        p.kind === "perfect" ? "#ffd54a" :
        p.kind === "good" ? "#7cf7ff" :
        p.kind === "ball" ? "#7cf7ff" :
        p.kind === "strike" ? "#ff6b6b" :
        "#ffffff";

      const safeX = clamp(p.x, 50, W - 50);
      ctx.fillText(p.text, safeX, p.y);
      ctx.restore();
    }

    if (derby.over){
      ctx.save();
      ctx.globalAlpha = 0.68;
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, W, H);
      ctx.globalAlpha = 1;
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.shadowColor = "rgba(0,0,0,0.55)";
      ctx.shadowBlur = 12;
      ctx.font = "950 44px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("DERBY OVER", W/2, H*0.40);
      ctx.font = "850 22px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText(`HR ${derby.homeruns}`, W/2, H*0.40 + 54);
      ctx.font = "750 16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("Tap RESTART to play again • Esc for Menu", W/2, H*0.40 + 92);
      ctx.restore();
    }

ctx.restore();
  }


// Skills
  function useSkillV(zone){
    if (gameMode === "derby") return;
    if (player.skillVCD > 0) return;
    player.skillVCD = player.skillVCDDur * upgrades.cdMul;
    fxVertT = 0.22;

    const stripeW = 140;
    const stripeX = (zone.x + zone.w/2) - stripeW/2;
    const dmg = 2 + upgrades.skillDamageBonus;

    const pool = boss.alive ? bossPitches : balls;
    for (const b of pool){
      if (!b.alive) continue;
      if (b.x >= stripeX && b.x <= stripeX + stripeW){
        if (boss.alive){
          b.alive = false;
          spawnExplosion(b.x, b.y, true);
        } else {
          dealDamageToEnemyBall(b, dmg, { fromSkill:true });
        }
      }
    }
  }

  function useSkillH(zone){
    if (gameMode === "derby") return;
    if (player.skillHCD > 0) return;
    player.skillHCD = player.skillHCDDur * upgrades.cdMul;
    fxHorzT = 0.22;

    const bandH = 110;
    const centerY = (zone.y + zone.h/2);
    const bandY = centerY - bandH/2;
    const dmg = 2 + upgrades.skillDamageBonus;

    const pool = boss.alive ? bossPitches : balls;
    for (const b of pool){
      if (!b.alive) continue;
      if (b.y >= bandY && b.y <= bandY + bandH){
        if (boss.alive){
          b.alive = false;
          spawnExplosion(b.x, b.y, true);
        } else {
          dealDamageToEnemyBall(b, dmg, { fromSkill:true });
        }
      }
    }
  }

  // Run control
  function resetRun(){
    score = 0;
  hp = HP_START;

    combo = 0;
    comboTimer = 0;

    upgrades.hitboxBonus = 0;
    upgrades.cdMul = 1.0;
    upgrades.perfectBonus = 0.00;
    upgrades.skillDamageBonus = 0;
    upgrades.autoPitchCount = 0;
    upgrades.autoPitchInterval = 5.0;
    upgrades.autoPitchT = 0;

    level = 1;
    levelKills = 0;
    levelTime = 0;
    levelBannerT = 1.4;

    buffs.slowmo = 0;
    buffs.double = 0;
    buffs.magnet = 0;
    buffs.shield = 0;

    setStance("righty");

    player.swing = false;
    player.swingTimer = 0;
    player.swingAge = 999;
    player.swingPoseTimer = 0;
    player.swingCD = 0;
    player.swingConsumed = false;

    player.skillVCD = 0;
    player.skillHCD = 0;
    fxVertT = 0;
    fxHorzT = 0;

    balls.length = 0;
    bossPitches.length = 0;
    returns.length = 0;
    explosions.length = 0;
    pickups.length = 0;
    shots.length = 0;
    popups.length = 0;

    spawnT = 0;

    hitStop = 0;
    shakeT = 0;
    shakeMag = 0;

    boss.alive = false;
    boss.hp = 0;
    boss.maxHp = 0;

    upgradeOpen = false;
    pendingNextLevel = null;
    upgradeModal.hidden = true;

    swingToken = 0;
    popupStackI = 0;

    aim.nx = 0;
    aim.ny = 0;
    setKnob(0, 0);

    aimStillT = 0;
    lastAimNX = 0;
    lastAimNY = 0;
  }

function startLevel(lv){
  level = lv;

  // Heal to full ONLY when starting a new level
  hp = HP_MAX;

  levelKills = 0;
  levelTime = 0;
  levelBannerT = 1.4;
  spawnT = 0;

  balls.length = 0;
  bossPitches.length = 0;
  returns.length = 0;
  explosions.length = 0;
  pickups.length = 0;
  popups.length = 0;

  boss.alive = false;
  boss.hp = 0;
  boss.maxHp = 0;
}

  function finishLevel(){
    openUpgradeModal(level + 1);
  }

  // ===== Keyboard (no-hold / no-repeat) =====
  const heldKeys = new Set();

  function keyName(e){
    return (e.key || "").toLowerCase();
  }

const keyDown = new Map(); // code -> boolean

window.addEventListener("keydown", (e) => {
  const code = e.code || "";

  if (code === "Escape") { showMenu(); return; }

  if (gameMode === "menu") {
    return;
  }

  // One-shot actions: fire once per physical press
  if (!e.repeat && code === "KeyJ") input.swing = true;
  if (!e.repeat && code === "KeyK") input.skillV = true;
  if (!e.repeat && code === "KeyL") input.skillH = true;

  keyDown.set(code, true);

  // aim keys (continuous is fine)
  const step = 0.11;
  if (code === "ArrowLeft")  aim.nx = clamp(aim.nx - step, -1, 1);
  if (code === "ArrowRight") aim.nx = clamp(aim.nx + step, -1, 1);
  if (code === "ArrowUp")    aim.ny = clamp(aim.ny - step, -1, 1);
  if (code === "ArrowDown")  aim.ny = clamp(aim.ny + step, -1, 1);
});

window.addEventListener("keyup", (e) => {
  keyDown.set(e.code || "", false);
});


  window.addEventListener("keyup", (e) => {
    heldKeys.delete(keyName(e));
  });

  window.addEventListener("blur", () => heldKeys.clear());
  document.addEventListener("visibilitychange", () => {
    if (document.hidden) heldKeys.clear();
  });

  // Step
  function step(dt, W, H){
    if (gameMode === "menu") return;
    if (stepCountdown(dt)) return;
    if (gameMode === "derby") { stepDerby(dt, W, H); return; }
    if (upgradeOpen) return;
    if (hp <= 0) return;

    if (hitStop > 0){
      hitStop -= dt;
      return;
    }

    if (buffs.slowmo > 0) buffs.slowmo = Math.max(0, buffs.slowmo - dt);
    if (buffs.double > 0) buffs.double = Math.max(0, buffs.double - dt);
    if (buffs.magnet > 0) buffs.magnet = Math.max(0, buffs.magnet - dt);

    const timeScale = (buffs.slowmo > 0) ? 0.65 : 1.0;
    const sdt = dt * timeScale;

    const spec = getLevelSpec(level);
    levelTime += sdt;

    if (combo > 0){
      comboTimer -= sdt;
      if (comboTimer <= 0) combo = 0;
    }
    // No swing cooldown
    player.swingCD = 0;
    player.skillVCD = Math.max(0, player.skillVCD - sdt);
    player.skillHCD = Math.max(0, player.skillHCD - sdt);

    if (fxVertT > 0) fxVertT = Math.max(0, fxVertT - sdt);
    if (fxHorzT > 0) fxHorzT = Math.max(0, fxHorzT - sdt);

    // popups
    for (const p of popups){
      if (!p.alive) continue;
      p.t += sdt;
      p.y += p.vy * sdt;
      if (p.t >= p.life) p.alive = false;
    }
    for (let i = popups.length - 1; i >= 0; i--){
      if (!popups[i].alive) popups.splice(i, 1);
    }

    // anchor player/zone
    const plate = getPlate(W, H);
    const band  = getContactBandFromPlate(W, H);

    const bandCx = band.x + band.w / 2;
    const playerCenterX = bandCx + (player.stance === "righty" ? -STANCE_OFFSET : STANCE_OFFSET);
    player.x = playerCenterX - player.w/2;
    player.y = clamp(plate.y - player.h + 14, 0, H - player.h - 10);

    const zone = getStrikeZoneFromPlate(W, H);
    lastZone = zone;

    const expandedZone = {
      x: zone.x - CHASE_MARGIN,
      y: zone.y - CHASE_MARGIN,
      w: zone.w + CHASE_MARGIN*2,
      h: zone.h + CHASE_MARGIN*2,
    };

    const aimPt = getAimPoint(zone);

    // Aim penalty tracking (works for joystick/mouse/arrows)
    const aimDelta = Math.hypot(aim.nx - lastAimNX, aim.ny - lastAimNY);
    if (aimDelta < AIM_STILL_EPS) aimStillT += sdt;
    else aimStillT = Math.max(0, aimStillT - sdt * 2.0);
    lastAimNX = aim.nx;
    lastAimNY = aim.ny;

    const aimPenalty01 = clamp01((aimStillT - AIM_STILL_T_START) / Math.max(0.0001, (AIM_STILL_T_FULL - AIM_STILL_T_START)));

    // swing input + timers
    if (input.swing) startSwing();
    input.swing = false;

    if (player.swing){
      player.swingTimer = Math.max(0, player.swingTimer - sdt);
      player.swingAge += sdt;
      player.swingPoseTimer = Math.max(0, player.swingPoseTimer - sdt);
      if (player.swingTimer <= 0) player.swing = false;
    } else {
      player.swingAge = Math.min(999, player.swingAge + sdt);
      player.swingPoseTimer = Math.max(0, player.swingPoseTimer - sdt);
    }

    const swingActive = (player.swing || player.swingAge <= player.swingWindow + LATE_GRACE);

    // skills
    if (input.skillV) useSkillV(zone);
    input.skillV = false;

    if (input.skillH) useSkillH(zone);
    input.skillH = false;

    // auto pitch
    if (upgrades.autoPitchCount > 0){
      upgrades.autoPitchT += sdt;
      if (upgrades.autoPitchT >= upgrades.autoPitchInterval){
        upgrades.autoPitchT = 0;
        fireAutoPitch(W, H);
      }
    }

    // boss start
    if (spec.type === "boss" && !boss.alive){
      startBossFight(W, H);
    }

    // spawn normal enemies
    if (spec.type !== "boss"){
      spawnT += sdt;
      const baseInterval = 1.05;
      const interval = Math.max(0.42, baseInterval - (level-1) * 0.05);

      if (spawnT >= interval){
        spawnT = 0;

        let kind = "normal";
        const themeNow = getTheme(level);
        const r = Math.random();

        if (themeNow === "subway"){
          if (r < 0.70) kind = "sandwich";
          else if (r < 0.84) kind = "fast";
          else if (r < 0.94) kind = "heavy";
          else kind = "normal";
        } else {
          const fastChance = Math.min(0.32, 0.08 + (level-1)*0.02);
          const heavyChance = Math.min(0.26, 0.06 + (level-1)*0.015);

          if (r < fastChance) kind = "fast";
          else if (r < fastChance + heavyChance) kind = "heavy";
        }

        spawnEnemy(W, H, zone, expandedZone, kind);

        if (level >= 7 && Math.random() < 0.10){
          spawnEnemy(W, H, zone, expandedZone, Math.random() < 0.5 ? "fast" : "normal");
        }
      }
    }

    // move normal enemies + plate-hold
    if (spec.type !== "boss"){
      const tx = band.x + band.w/2;
      const ty = band.y + band.h/2;

      for (const b of balls){
        if (!b.alive) continue;

        b.justHitT = Math.max(0, b.justHitT - sdt);


        if (!b.crossedZone && circleRectHit(b.x, b.y, b.r, zone.x, zone.y, zone.w, zone.h)) b.crossedZone = true;
        if (b.pendingPlate) continue;

        b.wobPhase += sdt * (b.wobSpeed || 8);

        if (!b.retargeted && b.toPlateDist < 520){
          b.retargeted = true;
          b.targetX = pickApproachX(zone, expandedZone);
        }

        const dx = (b.targetX ?? tx) - b.x;
        const dy = ty - b.y;

        const dist = Math.hypot(dx, dy) || 1;
        b.toPlateDist = dist;

        const dir = { x: dx/dist, y: dy/dist };
        const perp = { x: -dir.y, y: dir.x };

        const wave = b.zigzag ? triWave(b.wobPhase) : Math.sin(b.wobPhase);
        const wobAmp = (b.wobMag || 18) * (0.35 + 0.85 * clamp01(1 - (b.toPlateDist / 720)));
        const wob = wave * wobAmp;

        b.vx = dir.x * b.speed + perp.x * wob;
        b.vy = dir.y * b.speed + perp.y * wob;

        b.x += b.vx * sdt;
        b.y += b.vy * sdt;

        const minX = expandedZone.x + b.r;
        const maxX = expandedZone.x + expandedZone.w - b.r;
        b.x = clamp(b.x, minX, maxX);

        if (b.y + b.r >= band.bot){
          const hittableNow = swingActive && !player.swingConsumed &&
            circleRectHit(b.x, b.y, b.r, derbyHitZone.x, derbyHitZone.y, derbyHitZone.w, derbyHitZone.h);

          if (hittableNow){
            b.pendingPlate = true;
            b.y = band.bot - b.r - PLATE_HOLD_EPS;
          } else {
            b.alive = false;
            if (b.crossedZone){
              applyPlateDamage(1);
              spawnPopupStacked(b.x, band.y - 18, "STRIKE!", "strike");
            } else {
              spawnPopupStacked(b.x, band.y - 18, "BALL", "ball");
            }
          }
        }
      }
    }

    // boss update
    if (spec.type === "boss"){
      updateBossFight(sdt, W, H, zone, band, swingActive, expandedZone);
    }

    // pickups
    for (const p of pickups){
      p.t += sdt;
      p.vy += 900 * sdt;
      p.y += p.vy * sdt;

      const tx = band.x + band.w/2;
      p.x += (tx - p.x) * sdt * 0.25;

      if (circleRectHit(p.x, p.y, p.r, player.x, player.y, player.w, player.h)){
        p.alive = false;
        applyPickup(p.type);
      }
      if (p.y > H + 80) p.alive = false;
    }

    // explosions
    for (const ex of explosions){
      ex.t += sdt;
      const fd = 1 / ex.fps;
      while (ex.t >= fd){
        ex.t -= fd;
        ex.frame++;
        if (ex.frame >= ex.frameCount){
          ex.alive = false;
          break;
        }
      }
    }

    // shots
    updateShots(sdt, W, H);

    // SWING contact (one hit per swing)
    if (swingActive && !player.swingConsumed){
      const baseBatR = BAT_R_BASE + upgrades.hitboxBonus * BAT_R_PER_UPG;
      const batR = baseBatR * (1 - AIM_PENALTY_BAT_SHRINK * aimPenalty01);

      const perfectWindow = PERFECT_W;
      const goodWindow    = GOOD_W;

      const timing01 = clamp01(player.swingAge / Math.max(0.0001, player.swingWindow));
      const timeGrade =
        (player.swingAge <= perfectWindow) ? "perfect" :
        (player.swingAge <= goodWindow)    ? "good" :
        "normal";

      const thrPerfect = lerp(OVERLAP_PERFECT, 0.92, aimPenalty01);
      const thrGood    = lerp(OVERLAP_GOOD,    0.82, aimPenalty01);

      const pool = boss.alive ? bossPitches : balls;
      const STORY_HIT_PAD = 8; // try 6–12
      const hitZone = {
        x: zone.x - STORY_HIT_PAD,
        y: zone.y - STORY_HIT_PAD,
        w: zone.w + STORY_HIT_PAD * 2,
        h: zone.h + STORY_HIT_PAD * 2
      };
      const STORY_MIN_CONTACT_FRAC = 0.33; // higher = harder (0.28–0.40 sweet spot)


      let didAnyContact = false;

      for (const b of pool){
        if (!b.alive) continue;
        if (b.lastHitSwingToken === swingToken) continue;

        const inHittable = circleRectHit(b.x, b.y, b.r, hitZone.x, hitZone.y, hitZone.w, hitZone.h);
        if (!inHittable) continue;

        const d = Math.hypot(b.x - aimPt.x, b.y - aimPt.y);


const overlapA = circleOverlapArea(b.r, batR, d);
if (overlapA <= 0) continue;

const ballA = Math.PI * b.r * b.r;
const batA  = Math.PI * batR * batR;

// Normalize by smaller area so "solid contact" can actually reach 1.0
const frac = overlapA / Math.max(1e-6, Math.min(ballA, batA));

// Tune this. Start low.
if (frac < STORY_MIN_CONTACT_FRAC) continue;




        const overlapGrade =
          (frac >= thrPerfect) ? "perfect" :
          (frac >= thrGood)    ? "good" :
          "normal";

        let grade = "normal";
        if (
          (timeGrade === "perfect" && (overlapGrade === "perfect" || overlapGrade === "good")) ||
          (overlapGrade === "perfect" && (timeGrade === "perfect" || timeGrade === "good"))
        ){
          grade = "perfect";
        } else if (timeGrade !== "normal" && overlapGrade !== "normal"){
          grade = "good";
        }


        b.lastHitSwingToken = swingToken;
        b.pendingPlate = false;

        didAnyContact = true;

        if (boss.alive){
          b.alive = false;

          if (grade === "good") spawnPopupStacked(aimPt.x, aimPt.y - 22, "GOOD", "good");
          if (grade === "perfect") spawnPopupStacked(aimPt.x, aimPt.y - 22, "PERFECT!", "perfect");

          createReturnBall(b.x, b.y, grade, aimPt, zone, timing01);

          combo += (grade === "perfect") ? 2 : 1;
          comboTimer = COMBO_DECAY;

          shakeMag = Math.max(shakeMag, grade === "perfect" ? 14 : 10);
          shakeT = Math.max(shakeT, 0.16);
          spawnExplosion(b.x, b.y, grade !== "normal");
        } else {
          const didHit = dealDamageToEnemyBall(b, 1, { isPerfect: (grade === "perfect") });
          if (didHit && b.alive){
            b.justHitT = 0.22;
            b.y -= 26;
            b.vy = -Math.abs(b.vy) * 0.85;
            b.vx *= 0.55;
          }

          if (didHit){
            if (grade === "good"){
              spawnPopupStacked(aimPt.x, aimPt.y - 22, "GOOD", "good");
              combo += 1; comboTimer = COMBO_DECAY; score += 2 * getMult();
            } else if (grade === "perfect"){
              spawnPopupStacked(aimPt.x, aimPt.y - 22, "PERFECT!", "perfect");
              combo += 3; comboTimer = COMBO_DECAY; score += 6 * getMult();
            }
          }
        }

        if (didAnyContact){
          player.swingConsumed = true;
          endSwingImmediately();
          break;
        }
      }
    }

    // Resolve pending plate-cross AFTER swing
    if (!boss.alive){
      for (const b of balls){
        if (!b.alive) continue;
        if (!b.pendingPlate) continue;

        if (b.justHitT > 0){
          b.pendingPlate = false;
          continue;
        }

        b.pendingPlate = false;
        b.alive = false;
        if (b.crossedZone) applyPlateDamage(1);
      }
    } else {
      const bandRect = band;
      for (const p of bossPitches){
        if (!p.alive) continue;
        if (!p.pendingPlate) continue;

        p.pendingPlate = false;
        p.alive = false;

        const hitsPlateLane = circleRectHit(p.x, p.y, p.r, bandRect.x, bandRect.y, bandRect.w, bandRect.h);
        if (hitsPlateLane && p.crossedZone){
          applyPlateDamage(1);
          spawnPopupStacked(p.x, band.y - 18, "STRIKE!", "strike");
        } else if (hitsPlateLane && !p.crossedZone){
          spawnPopupStacked(p.x, band.y - 18, "BALL", "ball");
        }
      }
    }

    if (spec.type === "survive" && levelTime >= spec.target) finishLevel();

    // cleanup
    for (let i = balls.length - 1; i >= 0; i--) if (!balls[i].alive) balls.splice(i, 1);
    for (let i = explosions.length - 1; i >= 0; i--) if (!explosions[i].alive) explosions.splice(i, 1);
    for (let i = pickups.length - 1; i >= 0; i--) if (!pickups[i].alive) pickups.splice(i, 1);

    if (levelBannerT > 0) levelBannerT = Math.max(0, levelBannerT - sdt);

    if (shakeT > 0){
      shakeT = Math.max(0, shakeT - dt);
      shakeMag = Math.max(0, shakeMag - dt * 60);
    }

    // UI
    const mult = getMult();
    const shieldTxt = buffs.shield > 0 ? `🛡${buffs.shield} ` : "";
    const slowTxt = buffs.slowmo > 0 ? "🕒 " : "";
    const dblTxt = buffs.double > 0 ? "x2 " : "";
    const magTxt = buffs.magnet > 0 ? "🧲 " : "";
    const apTxt = upgrades.autoPitchCount > 0 ? `🎯${upgrades.autoPitchCount}/${upgrades.autoPitchInterval.toFixed(0)}s ` : "";

    let objTxt = "";
    if (spec.type === "kills") objTxt = `OBJ ${levelKills}/${spec.target}`;
    if (spec.type === "survive") objTxt = `OBJ ${Math.floor(levelTime)}/${spec.target}s`;
    if (spec.type === "boss") objTxt = boss.alive ? `BOSS ${boss.hp}/${boss.maxHp}` : "BOSS";

    const cdV = player.skillVCD > 0 ? player.skillVCD.toFixed(1) : "READY";
    const cdH = player.skillHCD > 0 ? player.skillHCD.toFixed(1) : "READY";

    const aimPenTxt = (aimStillT > AIM_STILL_T_START) ? ` 🎯MOVE ${Math.round(aimPenalty01*100)}%` : "";

    topbar.textContent =
      `Lv ${level} (${getTheme(level)}) • ${objTxt} • ${player.stance.toUpperCase()}${aimPenTxt}\n` +
      `Score ${score} • HP ${hp} • Combo ${combo} • x${mult} • ${shieldTxt}${slowTxt}${dblTxt}${magTxt}${apTxt}\n` +
      `VERT ${cdV} • HORZ ${cdH}`;
  }

  // Draw
  function draw(W, H){
    if (gameMode === "menu") { drawMenu(W, H); return; }
    if (gameMode === "derby") { drawDerby(ctx, W, H); drawCountdownOverlay(ctx, W, H); return; }


    let camX = 0, camY = 0;
    if (shakeT > 0){
      camX = (Math.random()*2 - 1) * shakeMag;
      camY = (Math.random()*2 - 1) * shakeMag;
    }

    ctx.save();
    ctx.translate(camX, camY);

    const theme = getTheme(level);
    const bg =
      (theme === "subway" && IMG.bg3) ? IMG.bg3 :
      (theme === "emoji" && IMG.bg2) ? IMG.bg2 :
      IMG.bg;

    if (bg){
      const ar = bg.width / bg.height;
      const tr = W / H;
      let dw, dh, dx, dy;
      if (ar > tr){ dh = H; dw = H * ar; dx = (W - dw)/2; dy = 0; }
      else { dw = W; dh = W / ar; dx = 0; dy = (H - dh)/2; }
      ctx.drawImage(bg, dx, dy, dw, dh);
    } else {
      ctx.fillStyle = "#101a3a";
      ctx.fillRect(0,0,W,H);
    }

    const plate = getPlate(W, H);
    const band  = getContactBandFromPlate(W, H);
    const zone  = getStrikeZoneFromPlate(W, H);
    lastZone = zone;

    const aimPt = getAimPoint(zone);

    const aimPenalty01 = clamp01((aimStillT - AIM_STILL_T_START) / Math.max(0.0001, (AIM_STILL_T_FULL - AIM_STILL_T_START)));
    const baseBatR = BAT_R_BASE + upgrades.hitboxBonus * BAT_R_PER_UPG;
    const batR = baseBatR * (1 - AIM_PENALTY_BAT_SHRINK * aimPenalty01);

    // BIG boss HP bar (top)
    if (boss.alive){
      const bw = Math.min(620, W - 40);
      const bh = 18;
      const bx = (W - bw) / 2;
      const by = 14;

      ctx.save();
      ctx.globalAlpha = 0.70;
      ctx.fillStyle = "#000";
      ctx.fillRect(bx, by, bw, bh);

      ctx.globalAlpha = 1;
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(255,255,255,0.70)";
      ctx.strokeRect(bx, by, bw, bh);

      const frac = clamp(boss.hp / Math.max(1, boss.maxHp), 0, 1);
      ctx.fillStyle = "#fff";
      ctx.fillRect(bx + 2, by + 2, (bw - 4) * frac, bh - 4);

      ctx.font = "950 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "#0b1020";
      ctx.fillText(`BOSS HP ${boss.hp}/${boss.maxHp}`, bx + bw/2, by + bh/2);
      ctx.restore();
    }

    // Strike zone
    if (STRIKE_ZONE_VISIBLE){
      ctx.save();
      ctx.globalAlpha = 0.14;
      ctx.fillStyle = "#00ffff";
      ctx.fillRect(zone.x, zone.y, zone.w, zone.h);
      ctx.globalAlpha = 0.92;
      ctx.lineWidth = 4;
      ctx.strokeStyle = "rgba(0,255,255,0.95)";
      ctx.strokeRect(zone.x, zone.y, zone.w, zone.h);

      ctx.globalAlpha = 0.28;
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(255,255,255,0.55)";
      ctx.strokeRect(zone.x - CHASE_MARGIN, zone.y - CHASE_MARGIN, zone.w + CHASE_MARGIN*2, zone.h + CHASE_MARGIN*2);
      ctx.restore();
    }

    // Bat circle (shows penalty)
    ctx.save();
    ctx.globalAlpha = 0.20;
    ctx.fillStyle = "rgba(0,0,0,0.60)";
    ctx.beginPath();
    ctx.arc(aimPt.x + 2, aimPt.y + 2, batR, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.08;
    ctx.fillStyle = "rgba(255,255,255,0.90)";
    ctx.beginPath();
    ctx.arc(aimPt.x, aimPt.y, batR, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.90;
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(255,255,255,0.92)";
    ctx.beginPath();
    ctx.arc(aimPt.x, aimPt.y, batR, 0, Math.PI*2);
    ctx.stroke();

    ctx.globalAlpha = 0.70;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(aimPt.x - 14, aimPt.y);
    ctx.lineTo(aimPt.x + 14, aimPt.y);
    ctx.moveTo(aimPt.x, aimPt.y - 14);
    ctx.lineTo(aimPt.x, aimPt.y + 14);
    ctx.stroke();
    ctx.restore();

    // bottom wash
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "#000";
    ctx.fillRect(0, band.y, W, H - band.y);
    ctx.globalAlpha = 1;

    // plate marker
    ctx.save();
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.ellipse(plate.x, plate.y + 18, 46, 16, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // Boss
    if (boss.alive){
      const bossImg =
        (theme === "subway" && IMG.enemy3) ? IMG.enemy3 :
        (theme === "emoji" && IMG.enemy2) ? IMG.enemy2 :
        IMG.ball;

      ctx.save();
      ctx.globalAlpha = 0.55;
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.ellipse(boss.x, boss.y + boss.r * 0.75, boss.r * 0.98, boss.r * 0.42, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.65)";
      ctx.shadowBlur = 14;
      ctx.shadowOffsetY = 6;
      if (bossImg) ctx.drawImage(bossImg, boss.x - boss.r, boss.y - boss.r, boss.r*2, boss.r*2);
      else {
        ctx.beginPath(); ctx.arc(boss.x, boss.y, boss.r, 0, Math.PI*2);
        ctx.fillStyle = "#ffcc33";
        ctx.fill();
      }
      ctx.restore();
    }

    // Player
    const useSwingPose = player.swingPoseTimer > 0;
    const pimg = useSwingPose ? IMG.pSwingFollow : IMG.player;

    if (pimg){
      ctx.save();
      const px = player.x, py = player.y;
      if (player.facing === -1){
        ctx.translate(px + player.w/2, 0);
        ctx.scale(-1, 1);
        ctx.translate(-(px + player.w/2), 0);
      }
      ctx.drawImage(pimg, px, py, player.w, player.h);
      ctx.restore();
    } else {
      ctx.fillStyle = "#fff";
      ctx.fillRect(player.x, player.y, player.w, player.h);
    }

    // friendly shots
    const shotImg = IMG.ball;
    for (const s of shots){
      if (!s.alive) continue;
      const size = s.r * 2;
      if (shotImg) ctx.drawImage(shotImg, s.x - s.r, s.y - s.r, size, size);
      else { ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fillStyle = "#fff"; ctx.fill(); }
    }

    // returns
    for (const r of returns){
      if (!r.alive) continue;
      const size = r.r * 2;
      if (shotImg) ctx.drawImage(shotImg, r.x - r.r, r.y - r.r, size, size);
      else { ctx.beginPath(); ctx.arc(r.x, r.y, r.r, 0, Math.PI*2); ctx.fillStyle = "#fff"; ctx.fill(); }
    }

    // enemies or boss pitches
    const defaultEnemyImg =
      (theme === "emoji" && IMG.enemy2) ? IMG.enemy2 :
      IMG.ball;

    const pool = boss.alive ? bossPitches : balls;

    for (const b of pool){
      if (!b.alive) continue;

      const enemyImg = (b.kind === "sandwich" && IMG.enemy3) ? IMG.enemy3 : defaultEnemyImg;
      const scale = (b.kind === "sandwich") ? 1.55 : 1.0;
      const size = b.r * 2 * scale;

      ctx.save();
      ctx.globalAlpha = 0.55;
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.ellipse(b.x, b.y + b.r * 0.60, b.r * 0.92, b.r * 0.42, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.65)";
      ctx.shadowBlur = (b.kind === "sandwich") ? 18 : 10;
      ctx.shadowOffsetY = 4;

      if (enemyImg){
        if (b.kind === "sandwich"){
          ctx.save();
          ctx.globalAlpha = 0.20;
          ctx.fillStyle = "#fff";
          ctx.beginPath();
          ctx.arc(b.x, b.y, b.r * 0.90, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        ctx.drawImage(enemyImg, b.x - size/2, b.y - size/2, size, size);
      } else {
        ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fillStyle = "#ff3b3b"; ctx.fill();
      }
      ctx.restore();

      if (boss.alive && b.pitchId && b.labelT > 0){
        ctx.save();
        ctx.globalAlpha = clamp(b.labelT / 0.75, 0, 1) * 0.95;
        ctx.font = "950 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.textAlign = "center";
        ctx.shadowColor = "rgba(0,0,0,0.55)";
        ctx.shadowBlur = 8;
        ctx.fillStyle = "#fff";
        ctx.fillText(b.pitchId, b.x, b.y - b.r - 14);
        ctx.restore();
      }
    }

    // pickups
    for (const p of pickups){
      ctx.globalAlpha = 0.9;
      ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fillStyle = "#ffffff";
      ctx.fill();
      ctx.globalAlpha = 1;

      ctx.fillStyle = "#0b1020";
      ctx.font = "900 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      const label = p.type === "slowmo" ? "S" : p.type === "double" ? "2X" : p.type === "magnet" ? "M" : "🛡";
      ctx.fillText(label, p.x, p.y + 5);
    }

    // explosions
    const exImg = IMG.explosion;
    if (exImg){
      for (const ex of explosions){
        const fw = exImg.width / ex.frameCount;
        const fh = exImg.height;
        const sx = ex.frame * fw;
        ctx.drawImage(exImg, sx, 0, fw, fh, ex.x - ex.size/2, ex.y - ex.size/2, ex.size, ex.size);
      }
    }

    // popups
    for (const p of popups){
      const t = clamp01(p.t / p.life);
      const a = 1 - t;
      const bump = 1 + Math.sin(Math.min(1, t) * Math.PI) * 0.20;

      ctx.save();
      ctx.globalAlpha = 0.95 * a;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.shadowColor = "rgba(0,0,0,0.55)";
      ctx.shadowBlur = 10;

      const fontSize = p.kind === "perfect" ? 34 : p.kind === "good" ? 28 : 24;
      ctx.font = `950 ${Math.round(fontSize * bump)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.fillStyle =
        p.kind === "perfect" ? "#ffd54a" :
        p.kind === "good" ? "#7cf7ff" :
        p.kind === "ball" ? "#7cf7ff" :
        p.kind === "strike" ? "#ff6b6b" :
        "#ffffff";

      const safeX = clamp(p.x, 50, W - 50);
      ctx.fillText(p.text, safeX, p.y);
      ctx.restore();
    }

    // level banner
    const spec = getLevelSpec(level);
    if (levelBannerT > 0 && hp > 0){
      const a = clamp(levelBannerT / 1.4, 0, 1);
      ctx.globalAlpha = 0.75 * a;
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, W, 86);
      ctx.globalAlpha = 1 * a;
      ctx.fillStyle = "#fff";
      ctx.font = "900 28px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "left";
      ctx.fillText(spec.banner, 16, 54);
      ctx.globalAlpha = 1;
    }

    // game over
    if (hp <= 0){
      ctx.globalAlpha = 0.65;
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha = 1;
      ctx.fillStyle = "#fff";
      ctx.font = "900 42px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      ctx.fillText("GAME OVER", W/2, H/2 - 12);
      ctx.font = "700 18px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("Tap RESTART.", W/2, H/2 + 26);
    }

    ctx.restore();

    drawCountdownOverlay(ctx, W, H);
  }

  // Loop
  let last = 0;
  function loop(ts){
    const W = DESIGN_W;
    const H = DESIGN_H;

    const dt = Math.min(0.033, (ts - last) / 1000 || 0);
    last = ts;

    step(dt, W, H);

    // Camera makes the fixed DESIGN world fill any screen (cover + crop).
    applyCamera(ctx);
    draw(W, H);

    requestAnimationFrame(loop);
  }

  // Boot
  Promise.all(ASSETS).finally(() => {
    resize();
    resetRun();
    showMenu();
    requestAnimationFrame(loop);
  });

})();
</script>
</body>
</html>