<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Urban Slugger Prototype</title>
<style>
  html, body { margin:0; height:100%; background:#0b1020; overflow:hidden; }
  #wrap { position:relative; width:100%; height:100%; touch-action:none; }
  canvas { display:block; width:100%; height:100%; }

  .hud{
    position:absolute; inset:0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
    color:#fff;
    pointer-events:none;
  }
  .topbar{
    position:absolute; left:10px; top:10px;
    background: rgba(0,0,0,.45);
    padding:8px 10px;
    border-radius:12px;
    pointer-events:none;
    font-weight:800;
    line-height:1.15;
    max-width: calc(100% - 20px);
    white-space: pre-line;
  }
  .hint{
    position:absolute; right:10px; top:10px;
    background: rgba(0,0,0,.35);
    padding:8px 10px;
    border-radius:12px;
    font-size:12px;
    pointer-events:none;
    text-align:right;
  }

  .controls{
    position:absolute; left:0; right:0; bottom:0;
    display:flex;
    justify-content:space-between;
    align-items:flex-end;
    gap:14px;
    pointer-events:auto;

    padding: 14px;
    padding-left:  calc(14px + env(safe-area-inset-left));
    padding-right: calc(14px + env(safe-area-inset-right));
    padding-bottom:calc(14px + env(safe-area-inset-bottom));
  }

  .pad, .btnCol{
    display:grid;
    gap:12px;
    pointer-events:auto;
  }

  .pad{
    grid-template-columns: 72px 72px;
    grid-template-rows: 72px 72px;
  }
  .btnCol{
    grid-template-columns: 72px 72px;
    grid-template-rows: 72px 72px;
    justify-content:end;
  }

  .wide{ grid-column: 1 / span 2; }

  .btn{
    width:72px; height:72px; border-radius:18px;
    background: rgba(255,255,255,.10);
    border: 1px solid rgba(255,255,255,.18);
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    color:#fff; font-weight:900;
    display:flex; align-items:center; justify-content:center;
    user-select:none; -webkit-user-select:none;
    touch-action:none;
  }
  .btn:active { transform: translateY(1px); }

  /* ===== Upgrade Modal ===== */
  .modal{
    position:absolute; inset:0;
    display:flex; align-items:center; justify-content:center;
    background: rgba(0,0,0,.55);
    pointer-events:auto;
    padding: 18px;
    padding-bottom: calc(18px + env(safe-area-inset-bottom));
  }
  .modal[hidden]{ display:none; }
  .panel{
    width:min(560px, 94vw);
    background: rgba(15,18,35,.92);
    border: 1px solid rgba(255,255,255,.18);
    border-radius: 18px;
    padding: 16px;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    box-shadow: 0 18px 50px rgba(0,0,0,.45);
  }
  .title{ font-weight: 950; font-size: 20px; margin-bottom: 6px; }
  .sub{ opacity:.9; font-weight:800; margin-bottom: 12px; }
  .sub2{ opacity:.7; font-size: 12px; margin-top: 10px; font-weight:800; }
  .choices{
    display:grid;
    grid-template-columns: 1fr;
    gap: 10px;
  }
  @media (min-width: 560px){
    .choices{ grid-template-columns: 1fr 1fr 1fr; }
  }
  .upg{
    border-radius: 16px;
    padding: 12px;
    background: rgba(255,255,255,.10);
    border: 1px solid rgba(255,255,255,.18);
    color:#fff;
    cursor:pointer;
    user-select:none;
    pointer-events:auto;
  }
  .upg:active{ transform: translateY(1px); }
  .upg .n{ font-weight: 950; margin-bottom: 4px; }
  .upg .d{ opacity:.88; font-weight: 800; font-size: 12px; line-height:1.25; }
  .upg .k{ opacity:.65; font-size: 12px; margin-top: 6px; font-weight:950; }

  /* Force landscape layout */
  @media screen and (orientation: portrait) {
    body::before {
      content: "Rotate your device â†»";
      position: fixed;
      inset: 0;
      background: #0b1020;
      color: #fff;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    canvas, .hud { display: none; }
  }
</style>
</head>

<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="topbar" id="topbar">Loadingâ€¦</div>
    <div class="hint">
      A/D move â€¢ Space jump<br/>
      J swing â€¢ K VERT â€¢ L HORZ<br/>
      R restart
    </div>

    <!-- UPGRADE MODAL -->
    <div class="modal" id="upgradeModal" hidden>
      <div class="panel">
        <div class="title" id="upgradeTitle">Level Complete!</div>
        <div class="sub" id="upgradeSub">Pick your upgrade.</div>
        <div class="choices" id="upgradeChoices"></div>
        <div class="sub2" id="upgradeTip">Tip: press 1 / 2 / 3 on keyboard (or tap a card).</div>
      </div>
    </div>

    <!-- Mobile Controls -->
    <div class="controls">
      <!-- LEFT THUMB: move + jump -->
      <div class="pad">
        <div class="btn wide" id="btnJump">JUMP</div>
        <div class="btn" id="btnLeft">â—€</div>
        <div class="btn" id="btnRight">â–¶</div>
      </div>

      <!-- RIGHT THUMB: skills + swing -->
      <div class="btnCol">
        <div class="btn" id="btnVert">VERT</div>
        <div class="btn" id="btnHorz">HORZ</div>
        <div class="btn wide" id="btnSwing">SWING</div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // ===== Canvas setup =====
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    canvas.width  = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
  }
  window.addEventListener("resize", resize);
  window.addEventListener("orientationchange", resize);

  // ===== Assets =====
  const IMG = {};
  function loadImg(key, src){
    return new Promise((res) => {
      const im = new Image();
      im.onload = () => { IMG[key] = im; res({key, ok:true, src}); };
      im.onerror = () => { console.warn("âŒ Asset failed:", src); res({key, ok:false, src}); };
      im.src = src;
    });
  }

  /*
    Put these in /assets:

    Existing:
    - back_alley_background.png
    - baeball_player.png
    - baseball_player_swing.png
    - evil_baseball_1.png
    - explosion.png

    NEW:
    - emoji_town_background.png
    - creepy_smile.png
    - vertical_slash_skill.png
    - horizontal_slash_skill.png
  */
  const ASSETS = [
    loadImg("bg", "assets/back_alley_background.png"),
    loadImg("bg2", "assets/emoji_town_background.png"),

    loadImg("player", "assets/baeball_player.png"),
    loadImg("pSwingFollow", "assets/baseball_player_swing.png"),

    loadImg("ball", "assets/evil_baseball_1.png"),
    loadImg("enemy2", "assets/creepy_smile.png"),

    loadImg("explosion", "assets/explosion.png"),

    loadImg("skillV", "assets/vertical_slash_skill.png"),
    loadImg("skillH", "assets/horizontal_slash_skill.png"),
  ];

  // ===== World =====
  const world = {
    gravity: 2200,
    groundYFrac: 0.84,
  };

  // ===== Player =====
  const player = {
    x: 220, y: 0,
    w: 120, h: 180,
    vx: 0, vy: 0,
    speed: 720,

    // double-jump
    maxJumps: 2,
    jumpsLeft: 2,

    jumpVel: -980,
    onGround: false,
    facing: 1,

    // swing + timing
    swing: false,
    swingTimer: 0,
    swingWindow: 0.18,
    swingAge: 999,
    swingPoseTimer: 0,
    swingPoseDur: 0.16,

    // light anti-spam
    swingCD: 0,
    swingCDDur: 0.10,

    // skills
    skillVCD: 0,
    skillHCD: 0,
    skillVCDDur: 6.0,
    skillHCDDur: 7.5,
  };

  // ===== Input =====
  const input = {
    left:false, right:false,
    jump:false, swing:false,
    skillV:false, skillH:false
  };

  function bindHold(el, key){
    const down = (e)=>{ e.preventDefault(); input[key] = true; };
    const up   = (e)=>{ e.preventDefault(); input[key] = false; };
    el.addEventListener("pointerdown", down);
    el.addEventListener("pointerup", up);
    el.addEventListener("pointercancel", up);
    el.addEventListener("pointerout", up);
    el.addEventListener("pointerleave", up);
  }
  function bindTap(el, key){
    el.addEventListener("pointerdown", (e)=>{ e.preventDefault(); input[key] = true; });
  }

  bindHold(document.getElementById("btnLeft"), "left");
  bindHold(document.getElementById("btnRight"), "right");
  bindTap(document.getElementById("btnJump"), "jump");
  bindTap(document.getElementById("btnSwing"), "swing");
  bindTap(document.getElementById("btnVert"), "skillV");
  bindTap(document.getElementById("btnHorz"), "skillH");

  // ===== Game state =====
  const topbar = document.getElementById("topbar");

  let score = 0;
  let hp = 3;

  // score-chaser
  let combo = 0;
  let comboTimer = 0;
  const COMBO_DECAY = 2.25;

  function getMult(){
    return Math.min(6, 1 + Math.floor(combo / 10));
  }

  // juice
  let hitStop = 0;
  let shakeT = 0;
  let shakeMag = 0;

  // skill FX timers
  let fxVertT = 0;
  let fxHorzT = 0;

  // powerups
  const buffs = {
    slowmo: 0,
    double: 0,
    magnet: 0,
    shield: 0,
  };

  // ===== Upgrades (per-level) =====
  const upgrades = {
    hitboxBonus: 0,          // increases swingW/swingH
    cdMul: 1.0,              // skill cooldown multiplier
    perfectBonus: 0.00,      // adds to perfect window
    skillDamageBonus: 0,     // +dmg to skills

    autoPitchCount: 0,       // friendly projectiles per volley
    autoPitchInterval: 5.0,  // seconds
    autoPitchT: 0,
  };

  const shots = []; // friendly projectiles

  // Levels/objectives
  let level = 1;
  let levelKills = 0;
  let levelTime = 0;
  let levelBannerT = 1.4;

  const LEVELS = [
    { type:"kills", target:8 },
    { type:"survive", target:18 },
    { type:"kills", target:14 },
    { type:"survive", target:24 },
    { type:"boss", target:1 },
  ];

  function getLevelSpec(lv){
    const base = LEVELS[(lv-1) % LEVELS.length];
    const tier = Math.floor((lv-1) / LEVELS.length);
    const scale = 1 + tier * 0.20;

    const spec = { ...base };
    if (spec.type === "kills") spec.target = Math.round(spec.target * scale);
    if (spec.type === "survive") spec.target = Math.round(spec.target * scale);
    if (spec.type === "boss") spec.target = 1;

    if (spec.type === "kills") spec.banner = `LEVEL ${lv} â€” Hit ${spec.target} balls`;
    if (spec.type === "survive") spec.banner = `LEVEL ${lv} â€” Survive ${spec.target}s`;
    if (spec.type === "boss") spec.banner = `LEVEL ${lv} â€” MINI BOSS`;

    return spec;
  }

  // Theme: make Emoji Town a new "level theme" starting at Level 6
  function getTheme(lv){
    return (lv >= 6) ? "emoji" : "alley";
  }

  // ===== Upgrade Modal UI =====
  const upgradeModal = document.getElementById("upgradeModal");
  const upgradeChoicesEl = document.getElementById("upgradeChoices");
  const upgradeTitle = document.getElementById("upgradeTitle");
  const upgradeSub = document.getElementById("upgradeSub");
  const upgradeTip = document.getElementById("upgradeTip");

  let upgradeOpen = false;
  let pendingNextLevel = null;

  const UPGRADE_CATALOG = {
    // the two you asked for
    hitbox_plus: {
      name: "Bigger Bat",
      desc: "+20px swing hitbox (easier hits).",
      apply(){ upgrades.hitboxBonus += 20; }
    },
    autopitch_2: {
      name: "Auto Pitch",
      desc: "Every 5s throw 2 friendly balls forward.",
      apply(){ upgrades.autoPitchCount = Math.max(upgrades.autoPitchCount, 2); }
    },

    // more upgrades (you said you want all the upgrades)
    cooldown: {
      name: "Quick Hands",
      desc: "Skill cooldowns -10%.",
      apply(){ upgrades.cdMul *= 0.90; }
    },
    hp: {
      name: "Extra Heart",
      desc: "+1 HP (cap 6).",
      apply(){ hp = Math.min(6, hp + 1); }
    },
    shield: {
      name: "Shield Charge",
      desc: "+1 shield (cap 3).",
      apply(){ buffs.shield = Math.min(3, buffs.shield + 1); }
    },
    perfect: {
      name: "Timing Master",
      desc: "Perfect window +0.02s.",
      apply(){ upgrades.perfectBonus += 0.02; }
    },
    skill_dmg: {
      name: "Sharper Skills",
      desc: "VERT/HORZ damage +1.",
      apply(){ upgrades.skillDamageBonus += 1; }
    },
    autopitch_3: {
      name: "Auto Pitch+",
      desc: "Auto Pitch now fires 3 balls.",
      apply(){ upgrades.autoPitchCount = Math.max(upgrades.autoPitchCount, 3); }
    },
    autopitch_faster: {
      name: "Rapid Pitch",
      desc: "Auto Pitch interval -1s (min 2s).",
      apply(){ upgrades.autoPitchInterval = Math.max(2.0, upgrades.autoPitchInterval - 1.0); }
    },
  };

  function getLevelUpgradeChoices(lv){
    // Your requested progression:
    // L1: Bigger Bat
    // L2: Auto Pitch (2 balls / 5s)
    if (lv === 1) return ["hitbox_plus"];   // forced
    if (lv === 2) return ["autopitch_2"];   // forced

    // Later levels: 3 choices
    const pool = [
      "hitbox_plus",
      "cooldown",
      "hp",
      "shield",
      "perfect",
      "skill_dmg",
      "autopitch_3",
      "autopitch_faster",
    ];

    // small helper: bias autopitch upgrades if you already have autopitch
    const weighted = pool.slice();
    if (upgrades.autoPitchCount > 0){
      weighted.push("autopitch_3","autopitch_faster");
    }

    const pick = [];
    while (pick.length < 3){
      const id = weighted[(Math.random()*weighted.length)|0];
      if (!pick.includes(id)) pick.push(id);
    }
    return pick;
  }

  function openUpgradeModal(nextLv){
    upgradeOpen = true;
    pendingNextLevel = nextLv;

    const choices = getLevelUpgradeChoices(level);
    upgradeTitle.textContent = `Level ${level} Complete!`;
    upgradeSub.textContent = (choices.length === 1) ? "Upgrade unlocked. Tap to continue." : "Pick your upgrade.";
    upgradeTip.textContent = (choices.length === 1) ? "Tap the card to continue." : "Tip: press 1 / 2 / 3 on keyboard (or tap a card).";

    upgradeChoicesEl.innerHTML = choices.map((id, idx) => {
      const u = UPGRADE_CATALOG[id];
      const keyHint = (choices.length === 1) ? "" : `(${idx+1})`;
      return `
        <div class="upg" data-upg="${id}" data-idx="${idx}">
          <div class="n">${u?.name ?? id}</div>
          <div class="d">${u?.desc ?? ""}</div>
          <div class="k">${keyHint}</div>
        </div>
      `;
    }).join("");

    upgradeModal.hidden = false;
  }

  function closeUpgradeModal(){
    upgradeOpen = false;
    upgradeModal.hidden = true;
  }

  function chooseUpgradeByIndex(i){
    const el = upgradeChoicesEl.querySelector(`.upg[data-idx="${i}"]`);
    if (!el) return;
    const id = el.dataset.upg;

    UPGRADE_CATALOG[id]?.apply?.();

    // tiny juice reward
    buffs.double = Math.max(buffs.double, 1.2);
    shakeMag = Math.max(shakeMag, 9);
    shakeT = Math.max(shakeT, 0.22);

    closeUpgradeModal();
    startLevel(pendingNextLevel);
    pendingNextLevel = null;
  }

  upgradeChoicesEl.addEventListener("pointerup", (e) => {
    const card = e.target.closest(".upg");
    if (!card) return;
    const idx = Number(card.dataset.idx);
    chooseUpgradeByIndex(idx);
  });

  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();

    if (k === "r") resetRun();

    // when upgrade modal is open, 1/2/3 selects
    if (!upgradeOpen) return;
    if (k === "1") chooseUpgradeByIndex(0);
    if (k === "2") chooseUpgradeByIndex(1);
    if (k === "3") chooseUpgradeByIndex(2);
  });

  window.addEventListener("keyup", (e) => {
    const k = e.key.toLowerCase();
    if (k === "a" || k === "arrowleft") input.left = false;
    if (k === "d" || k === "arrowright") input.right = false;
  });

  // Keydown (movement/skills) â€” keep separate so upgrade modal still allows 1/2/3
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (k === "a" || k === "arrowleft") input.left = true;
    if (k === "d" || k === "arrowright") input.right = true;
    if (k === " ") input.jump = true;
    if (k === "j") input.swing = true;
    if (k === "k") input.skillV = true;
    if (k === "l") input.skillH = true;
  });

  // ===== Entities =====
  const balls = [];
  const explosions = [];
  const pickups = [];
  let spawnT = 0;

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function circleRectHit(cx, cy, r, rx, ry, rw, rh){
    const nx = clamp(cx, rx, rx+rw);
    const ny = clamp(cy, ry, ry+rh);
    const dx = cx - nx, dy = cy - ny;
    return (dx*dx + dy*dy) <= r*r;
  }

  function startSwing(){
    if (player.swingCD > 0) return;
    player.swing = true;
    player.swingTimer = player.swingWindow;
    player.swingAge = 0;
    player.swingPoseTimer = player.swingPoseDur;
    player.swingCD = player.swingCDDur;
  }

  function spawnExplosion(x, y, big=false){
    explosions.push({
      x, y,
      frame: 0,
      t: 0,
      fps: 24,
      frameCount: 5,
      size: big ? 120 : 96,
      alive: true
    });
  }

  function maybeDropPickup(x, y){
    const p = 0.08 + Math.min(0.06, combo / 200);
    if (Math.random() > p) return;

    const roll = Math.random();
    let type = "double";
    if (roll < 0.25) type = "slowmo";
    else if (roll < 0.50) type = "double";
    else if (roll < 0.75) type = "magnet";
    else type = "shield";

    pickups.push({
      x, y,
      r: 18,
      vy: -240,
      t: 0,
      type,
      alive: true
    });
  }

  function applyPickup(type){
    if (type === "slowmo") buffs.slowmo = Math.max(buffs.slowmo, 3.0);
    if (type === "double") buffs.double = Math.max(buffs.double, 5.0);
    if (type === "magnet") buffs.magnet = Math.max(buffs.magnet, 5.0);
    if (type === "shield") buffs.shield = Math.min(3, buffs.shield + 1);

    shakeMag = Math.max(shakeMag, 4);
    shakeT = Math.max(shakeT, 0.12);
  }

  function spawnBall(W, H, kind="normal"){
    const groundY = H * world.groundYFrac;
    const y = groundY - (120 + Math.random()*220);

    const speedScale = 1 + (level-1) * 0.06;

    let r = 42, hpv = 1, scoreV = 10, vx = -(520 + Math.random()*260) * speedScale;

    if (kind === "fast"){
      r = 30; hpv = 1; scoreV = 18;
      vx = -(760 + Math.random()*260) * speedScale;
    }
    if (kind === "heavy"){
      r = 52; hpv = 2; scoreV = 25;
      vx = -(420 + Math.random()*180) * speedScale;
    }
    if (kind === "boss"){
      r = 72; hpv = 6; scoreV = 120;
      vx = -(360 + Math.random()*120) * (1 + (level-1)*0.03);
    }

    balls.push({
      kind,
      x: W + 80,
      y,
      r,
      vx,
      alive: true,
      phase: Math.random()*Math.PI*2,
      hp: hpv,
      scoreV,
    });
  }

  function resetRun(){
    score = 0;
    hp = 3;

    combo = 0;
    comboTimer = 0;

    // reset upgrades (fresh run)
    upgrades.hitboxBonus = 0;
    upgrades.cdMul = 1.0;
    upgrades.perfectBonus = 0.00;
    upgrades.skillDamageBonus = 0;
    upgrades.autoPitchCount = 0;
    upgrades.autoPitchInterval = 5.0;
    upgrades.autoPitchT = 0;

    level = 1;
    levelKills = 0;
    levelTime = 0;
    levelBannerT = 1.4;

    buffs.slowmo = 0;
    buffs.double = 0;
    buffs.magnet = 0;
    buffs.shield = 0;

    player.x = 220;
    player.y = 0;
    player.vx = 0;
    player.vy = 0;
    player.onGround = false;
    player.facing = 1;

    player.maxJumps = 2;
    player.jumpsLeft = player.maxJumps;

    player.swing = false;
    player.swingTimer = 0;
    player.swingAge = 999;
    player.swingPoseTimer = 0;
    player.swingCD = 0;

    player.skillVCD = 0;
    player.skillHCD = 0;
    fxVertT = 0;
    fxHorzT = 0;

    balls.length = 0;
    explosions.length = 0;
    pickups.length = 0;
    shots.length = 0;
    spawnT = 0;

    hitStop = 0;
    shakeT = 0;
    shakeMag = 0;

    // close modal if open
    upgradeOpen = false;
    pendingNextLevel = null;
    upgradeModal.hidden = true;
  }

  function startLevel(lv){
    level = lv;
    levelKills = 0;
    levelTime = 0;
    levelBannerT = 1.4;
    spawnT = 0;

    balls.length = 0;
    explosions.length = 0;
    pickups.length = 0;

    const spec = getLevelSpec(level);
    if (spec.type === "boss"){
      const W = canvas.clientWidth, H = canvas.clientHeight;
      spawnBall(W, H, "boss");
    }
  }

  function finishLevel(){
    // Open upgrade picker and pause game until chosen
    openUpgradeModal(level + 1);
  }

  // ===== Friendly Auto Pitch =====
  function fireAutoPitch(){
    if (upgrades.autoPitchCount <= 0) return;

    const baseY = player.y + 92;
    const startX = player.x + player.w - 6;

    for (let i = 0; i < upgrades.autoPitchCount; i++){
      const spread = (i - (upgrades.autoPitchCount-1)/2) * 22;
      shots.push({
        x: startX,
        y: baseY + spread,
        r: 14,
        vx: 920,
        alive: true,
        dmg: 1,
      });
    }
  }

  function updateShots(dt, W, H){
    for (const s of shots){
      if (!s.alive) continue;
      s.x += s.vx * dt;

      if (s.x > W + 60) s.alive = false;

      for (const b of balls){
        if (!b.alive) continue;
        const dx = b.x - s.x, dy = b.y - s.y;
        const rr = (b.r + s.r);
        if ((dx*dx + dy*dy) <= rr*rr){
          s.alive = false;
          dealDamageToBall(b, s.dmg, W, H, { fromSkill:true });
          break;
        }
      }
    }
    for (let i = shots.length - 1; i >= 0; i--){
      if (!shots[i].alive) shots.splice(i, 1);
    }
  }

  // Unified ball damage (used by swing & skills & shots)
  function dealDamageToBall(b, dmg, W, H, {isPerfect=false, fromSkill=false} = {}){
    if (!b.alive) return false;

    b.hp -= dmg;

    // juice
    hitStop = fromSkill ? 0.06 : (isPerfect ? 0.085 : 0.045);
    shakeMag = Math.max(shakeMag, fromSkill ? 12 : (isPerfect ? 14 : 9));
    shakeT = Math.max(shakeT, fromSkill ? 0.20 : (isPerfect ? 0.22 : 0.16));

    // chip hits (heavy/boss)
    if (b.hp > 0){
      combo++;
      comboTimer = COMBO_DECAY;
      score += Math.round(6 * getMult() * (buffs.double > 0 ? 2 : 1));
      spawnExplosion(b.x, b.y, false);
      return true;
    }

    // killed
    b.alive = false;

    combo++;
    comboTimer = COMBO_DECAY;

    const mult = getMult();
    const bonus = isPerfect ? 1.35 : 1.0;
    const doubleOn = (buffs.double > 0) ? 2 : 1;

    score += Math.round(b.scoreV * mult * bonus * doubleOn);
    levelKills++;

    spawnExplosion(b.x, b.y, isPerfect || fromSkill);
    maybeDropPickup(b.x, b.y);

    // objective check
    const spec = getLevelSpec(level);
    if (!upgradeOpen){
      if (spec.type === "kills" && levelKills >= spec.target) finishLevel();
      if (spec.type === "boss" && levelKills >= spec.target) finishLevel();
    }
    return true;
  }

  // ===== Main step =====
  function step(dt, W, H){
    // pause gameplay while upgrade picker is open
    if (upgradeOpen) return;

    if (hitStop > 0){
      hitStop -= dt;
      return;
    }

    // buffs tick
    if (buffs.slowmo > 0) buffs.slowmo = Math.max(0, buffs.slowmo - dt);
    if (buffs.double > 0) buffs.double = Math.max(0, buffs.double - dt);
    if (buffs.magnet > 0) buffs.magnet = Math.max(0, buffs.magnet - dt);

    // slowmo timeScale
    const timeScale = (buffs.slowmo > 0) ? 0.65 : 1.0;
    const sdt = dt * timeScale;

    // level timers
    const spec = getLevelSpec(level);
    levelTime += sdt;

    // combo decay
    if (combo > 0){
      comboTimer -= sdt;
      if (comboTimer <= 0) combo = 0;
    }

    // cooldowns
    if (player.swingCD > 0) player.swingCD = Math.max(0, player.swingCD - sdt);
    player.skillVCD = Math.max(0, player.skillVCD - sdt);
    player.skillHCD = Math.max(0, player.skillHCD - sdt);

    if (fxVertT > 0) fxVertT = Math.max(0, fxVertT - sdt);
    if (fxHorzT > 0) fxHorzT = Math.max(0, fxHorzT - sdt);

    // Auto Pitch tick
    if (upgrades.autoPitchCount > 0){
      upgrades.autoPitchT += sdt;
      if (upgrades.autoPitchT >= upgrades.autoPitchInterval){
        upgrades.autoPitchT = 0;
        fireAutoPitch();
      }
    }

    // move
    const dir = (input.right ? 1 : 0) - (input.left ? 1 : 0);
    player.vx = dir * player.speed;
    if (dir !== 0) player.facing = dir;

    // jump (double jump)
    if (input.jump && player.jumpsLeft > 0){
      const isSecond = (player.jumpsLeft === 1);
      player.vy = player.jumpVel * (isSecond ? 0.92 : 1.0);
      player.onGround = false;
      player.jumpsLeft--;
    }
    input.jump = false;

    // swing
    if (input.swing) startSwing();
    input.swing = false;

    // physics
    const groundY = H * world.groundYFrac;
    player.vy += world.gravity * sdt;
    player.x += player.vx * sdt;
    player.y += player.vy * sdt;

    player.x = clamp(player.x, 40, W - 40 - player.w);

    // ground
    const footY = player.y + player.h;
    if (footY >= groundY){
      player.y = groundY - player.h;
      player.vy = 0;
      player.onGround = true;
      player.jumpsLeft = player.maxJumps;
    }

    // swing timers
    if (player.swing){
      player.swingTimer -= sdt;
      player.swingAge += sdt;
      if (player.swingTimer <= 0) player.swing = false;
    } else {
      player.swingAge = 999;
    }

    if (player.swingPoseTimer > 0){
      player.swingPoseTimer = Math.max(0, player.swingPoseTimer - sdt);
    }

    // spawn logic
    if (!upgradeOpen){
      spawnT += sdt;

      const baseInterval = 1.05;
      const interval = Math.max(0.42, baseInterval - (level-1) * 0.05);

      const allowSpawns = (spec.type !== "boss") || (level >= 10);
      if (allowSpawns && spawnT >= interval){
        spawnT = 0;

        const r = Math.random();
        let kind = "normal";

        const fastChance = Math.min(0.30, 0.08 + (level-1)*0.02);
        const heavyChance = Math.min(0.24, 0.06 + (level-1)*0.015);

        if (r < fastChance) kind = "fast";
        else if (r < fastChance + heavyChance) kind = "heavy";

        spawnBall(W, H, kind);

        if (level >= 7 && Math.random() < 0.10){
          spawnBall(W, H, Math.random() < 0.5 ? "fast" : "normal");
        }
      }
    }

    // update balls
    for (const b of balls){
      b.x += b.vx * sdt;
      b.phase += sdt * (b.kind === "boss" ? 3 : 6);
      b.y += Math.sin(b.phase) * (b.kind === "boss" ? 2.0 : 0.6);

      if (b.x < -120 && b.alive){
        b.alive = false;

        if (buffs.shield > 0){
          buffs.shield--;
        } else {
          hp = Math.max(0, hp - (b.kind === "boss" ? 2 : 1));
        }

        combo = 0;
        comboTimer = 0;

        shakeMag = Math.max(shakeMag, 10);
        shakeT = Math.max(shakeT, 0.20);
      }
    }

    // update pickups
    for (const p of pickups){
      p.t += sdt;
      p.vy += 900 * sdt;
      p.y += p.vy * sdt;
      p.x -= 60 * sdt;

      const hit = circleRectHit(p.x, p.y, p.r, player.x, player.y, player.w, player.h);
      if (hit){
        p.alive = false;
        applyPickup(p.type);
      }
      if (p.y > H + 60) p.alive = false;
    }

    // update explosions
    for (const ex of explosions){
      ex.t += sdt;
      const fd = 1 / ex.fps;
      while (ex.t >= fd){
        ex.t -= fd;
        ex.frame++;
        if (ex.frame >= ex.frameCount){
          ex.alive = false;
          break;
        }
      }
    }

    // update friendly shots
    updateShots(sdt, W, H);

    // ===== SKILLS =====
    // VERT: hit everything in a vertical column in front of player (global top->bottom)
    if (input.skillV && player.skillVCD <= 0){
      player.skillVCD = player.skillVCDDur * upgrades.cdMul;
      fxVertT = 0.22;

      const stripeW = 110;
      const stripeX = (player.facing === 1)
        ? (player.x + player.w + 30)
        : (player.x - 30 - stripeW);

      const dmg = 2 + upgrades.skillDamageBonus;

      for (const b of balls){
        if (!b.alive) continue;
        if (b.x >= stripeX && b.x <= stripeX + stripeW){
          dealDamageToBall(b, dmg, W, H, { fromSkill:true });
        }
      }
    }
    input.skillV = false;

    // HORZ: hit everything in a horizontal row band (global left->right)
    if (input.skillH && player.skillHCD <= 0){
      player.skillHCD = player.skillHCDDur * upgrades.cdMul;
      fxHorzT = 0.22;

      const bandY = player.y + 95;
      const bandH = 90;

      const dmg = 2 + upgrades.skillDamageBonus;

      for (const b of balls){
        if (!b.alive) continue;
        if (b.y >= bandY && b.y <= bandY + bandH){
          dealDamageToBall(b, dmg, W, H, { fromSkill:true });
        }
      }
    }
    input.skillH = false;

    // ===== SWING HITBOX (pulled in closer + upgrade scaling) =====
    if (player.swing){
      let swingW = 120; // was 140
      let swingH = 95;  // was 110

      // level upgrades increase hitbox
      swingW += upgrades.hitboxBonus;
      swingH += Math.round(upgrades.hitboxBonus * 0.75);

      if (buffs.magnet > 0){
        swingW += 24;
        swingH += 18;
      }

      const inset = 28;
      const sx = (player.facing === 1)
        ? (player.x + player.w - inset)
        : (player.x - swingW + inset);

      const sy = player.y + 68;

      const perfectWindow = 0.055 + upgrades.perfectBonus;
      const isPerfect = player.swingAge <= perfectWindow;

      for (const b of balls){
        if (!b.alive) continue;
        if (circleRectHit(b.x, b.y, b.r, sx, sy, swingW, swingH)){
          dealDamageToBall(b, 1, W, H, { isPerfect, fromSkill:false });
        }
      }
    }

    // survival objective check
    if (spec.type === "survive"){
      if (levelTime >= spec.target){
        finishLevel();
      }
    }

    // cleanup
    for (let i = balls.length - 1; i >= 0; i--){
      if (!balls[i].alive) balls.splice(i, 1);
    }
    for (let i = explosions.length - 1; i >= 0; i--){
      if (!explosions[i].alive) explosions.splice(i, 1);
    }
    for (let i = pickups.length - 1; i >= 0; i--){
      if (!pickups[i].alive) pickups.splice(i, 1);
    }

    // banner timer
    if (levelBannerT > 0) levelBannerT = Math.max(0, levelBannerT - sdt);

    // shake
    if (shakeT > 0){
      shakeT = Math.max(0, shakeT - dt);
      shakeMag = Math.max(0, shakeMag - dt * 60);
    }

    // UI
    const mult = getMult();
    const shieldTxt = buffs.shield > 0 ? `ðŸ›¡${buffs.shield} ` : "";
    const slowTxt = buffs.slowmo > 0 ? "ðŸ•’ " : "";
    const dblTxt = buffs.double > 0 ? "x2 " : "";
    const magTxt = buffs.magnet > 0 ? "ðŸ§² " : "";
    const apTxt = upgrades.autoPitchCount > 0 ? `ðŸŽ¯${upgrades.autoPitchCount}/${upgrades.autoPitchInterval.toFixed(0)}s ` : "";

    let objTxt = "";
    if (spec.type === "kills") objTxt = `OBJ ${levelKills}/${spec.target}`;
    if (spec.type === "survive") objTxt = `OBJ ${Math.floor(levelTime)}/${spec.target}s`;
    if (spec.type === "boss") objTxt = `OBJ BOSS`;

    const cdV = player.skillVCD > 0 ? player.skillVCD.toFixed(1) : "READY";
    const cdH = player.skillHCD > 0 ? player.skillHCD.toFixed(1) : "READY";

    topbar.textContent =
      `Lv ${level} (${getTheme(level)}) â€¢ ${objTxt}\n` +
      `Score ${score} â€¢ HP ${hp} â€¢ Combo ${combo} â€¢ x${mult} â€¢ ${shieldTxt}${slowTxt}${dblTxt}${magTxt}${apTxt}\n` +
      `VERT ${cdV} â€¢ HORZ ${cdH}`;
  }

  // ===== Draw =====
  function draw(W, H){
    // camera shake
    let camX = 0, camY = 0;
    if (shakeT > 0){
      camX = (Math.random()*2 - 1) * shakeMag;
      camY = (Math.random()*2 - 1) * shakeMag;
    }

    ctx.save();
    ctx.translate(camX, camY);

    // Background (theme-based)
    const theme = getTheme(level);
    const bg = (theme === "emoji" && IMG.bg2) ? IMG.bg2 : IMG.bg;

    if (bg){
      const ar = bg.width / bg.height;
      const tr = W / H;
      let dw, dh, dx, dy;
      if (ar > tr){ dh = H; dw = H * ar; dx = (W - dw)/2; dy = 0; }
      else { dw = W; dh = W / ar; dx = 0; dy = (H - dh)/2; }
      ctx.drawImage(bg, dx, dy, dw, dh);
    } else {
      ctx.clearRect(-camX, -camY, W, H);
      ctx.fillStyle = "#101a3a";
      ctx.fillRect(0,0,W,H);
    }

    // Ground shadow
    const groundY = H * world.groundYFrac;
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "#000";
    ctx.fillRect(0, groundY, W, H-groundY);
    ctx.globalAlpha = 1;

    // Skill FX overlays
    if (fxVertT > 0){
      const a = fxVertT / 0.22;
      ctx.globalAlpha = 0.95 * a;

      const stripeW = 110;
      const stripeX = (player.facing === 1)
        ? (player.x + player.w + 30)
        : (player.x - 30 - stripeW);

      const im = IMG.skillV;
      if (im){
        ctx.drawImage(im, stripeX - 20, 0, stripeW + 40, H);
      } else {
        ctx.globalAlpha = 0.22 * a;
        ctx.fillStyle = "#fff";
        ctx.fillRect(stripeX, 0, stripeW, H);
      }
      ctx.globalAlpha = 1;
    }

    if (fxHorzT > 0){
      const a = fxHorzT / 0.22;
      ctx.globalAlpha = 0.95 * a;

      const bandY = player.y + 95;
      const bandH = 90;

      const im = IMG.skillH;
      if (im){
        ctx.drawImage(im, 0, bandY - 10, W, bandH + 20);
      } else {
        ctx.globalAlpha = 0.22 * a;
        ctx.fillStyle = "#fff";
        ctx.fillRect(0, bandY, W, bandH);
      }
      ctx.globalAlpha = 1;
    }

    // Player (swap to follow-through pose)
    const useSwingPose = player.swingPoseTimer > 0;
    const pimg = useSwingPose ? IMG.pSwingFollow : IMG.player;

    if (pimg){
      ctx.save();
      const px = player.x;
      const py = player.y;
      if (player.facing === -1){
        ctx.translate(px + player.w/2, 0);
        ctx.scale(-1, 1);
        ctx.translate(-(px + player.w/2), 0);
      }
      ctx.drawImage(pimg, px, py, player.w, player.h);
      ctx.restore();
    } else {
      ctx.fillStyle = "#fff";
      ctx.fillRect(player.x, player.y, player.w, player.h);
    }

    // Friendly shots (Auto Pitch)
    const shotImg = IMG.ball; // keep consistent
    for (const s of shots){
      if (!s.alive) continue;
      const size = s.r * 2;
      if (shotImg) ctx.drawImage(shotImg, s.x - s.r, s.y - s.r, size, size);
      else {
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
        ctx.fillStyle = "#fff";
        ctx.fill();
      }
    }

    // Enemies (theme-based sprite)
    const enemyImg = (theme === "emoji" && IMG.enemy2) ? IMG.enemy2 : IMG.ball;

    for (const b of balls){
      if (!b.alive) continue;

      const size = b.r * 2;
      if (enemyImg){
        ctx.drawImage(enemyImg, b.x - b.r, b.y - b.r, size, size);
      } else {
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
        ctx.fillStyle = b.kind === "boss" ? "#ffcc33" : "#ff3b3b";
        ctx.fill();
      }

      // boss HP bar
      if (b.kind === "boss"){
        const w = 120, h = 10;
        const px = b.x - w/2, py = b.y - b.r - 18;
        ctx.globalAlpha = 0.75;
        ctx.fillStyle = "#000";
        ctx.fillRect(px, py, w, h);
        ctx.globalAlpha = 1;
        ctx.fillStyle = "#fff";
        const frac = clamp(b.hp / 6, 0, 1);
        ctx.fillRect(px+1, py+1, (w-2)*frac, h-2);
      }
    }

    // Pickups
    for (const p of pickups){
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fillStyle = "#ffffff";
      ctx.fill();
      ctx.globalAlpha = 1;

      ctx.fillStyle = "#0b1020";
      ctx.font = "900 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      const label = p.type === "slowmo" ? "S" : p.type === "double" ? "2X" : p.type === "magnet" ? "M" : "ðŸ›¡";
      ctx.fillText(label, p.x, p.y + 5);
    }

    // Explosions
    const exImg = IMG.explosion;
    if (exImg){
      for (const ex of explosions){
        const fw = exImg.width / ex.frameCount;
        const fh = exImg.height;
        const sx = ex.frame * fw;
        ctx.drawImage(
          exImg,
          sx, 0, fw, fh,
          ex.x - ex.size/2,
          ex.y - ex.size/2,
          ex.size,
          ex.size
        );
      }
    }

    // Level banner
    const spec = getLevelSpec(level);
    if (levelBannerT > 0 && hp > 0){
      const a = clamp(levelBannerT / 1.4, 0, 1);
      ctx.globalAlpha = 0.75 * a;
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, W, 86);
      ctx.globalAlpha = 1 * a;
      ctx.fillStyle = "#fff";
      ctx.font = "900 28px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "left";
      ctx.fillText(spec.banner, 16, 54);
      ctx.globalAlpha = 1;
    }

    // Game over
    if (hp <= 0){
      ctx.globalAlpha = 0.65;
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha = 1;
      ctx.fillStyle = "#fff";
      ctx.font = "900 42px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      ctx.fillText("GAME OVER", W/2, H/2 - 12);
      ctx.font = "700 18px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("Press R to restart.", W/2, H/2 + 26);
    }

    ctx.restore();
  }

  // ===== Loop =====
  let last = 0;
  function loop(ts){
    const W = canvas.clientWidth;
    const H = canvas.clientHeight;

    const dt = Math.min(0.033, (ts - last) / 1000 || 0);
    last = ts;

    if (hp > 0) step(dt, W, H);
    draw(W, H);

    requestAnimationFrame(loop);
  }

  // ===== Boot =====
  Promise.all(ASSETS).then((results) => {
    console.log("Assets:", results);
  }).finally(() => {
    resize();
    resetRun();
    requestAnimationFrame(loop);
  });

})();
</script>
</body>
</html>
